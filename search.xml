<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Query Graph Generation for Answering Multi-hop Complex Questions from Knowledge Bases</title>
      <link href="/2020/06/26/Query-Graph-Generation-for-Answering-Multi-hop-Complex-Questions-from-Knowledge-Bases/"/>
      <url>/2020/06/26/Query-Graph-Generation-for-Answering-Multi-hop-Complex-Questions-from-Knowledge-Bases/</url>
      
        <content type="html"><![CDATA[<h1 id="文章信息">1. 文章信息</h1><ul><li>Lan, Yunshi, and Jing Jiang. &quot;Query Graph Generation for Answering Multi-hop Complex Questions from Knowledge Bases.&quot; <em>Proceedings of the 58th Annual Meeting of the Association for Computational Linguistics</em>. 2020.</li><li>ACL2020</li><li>ComplexWebQuestons数据集、WebQuestionsSP 数据集、ComplexQuestions 数据集</li><li><a href="https://github.com/lanyunshi/Multi-hopComplexKBQA" target="_blank" rel="noopener">github</a></li></ul><h1 id="研究领域与目标">2. 研究领域与目标</h1><h2 id="研究领域">2.1 研究领域</h2><ul><li>知识图谱问答</li><li>带约束的问题、多跳关系问题</li><li>语义解析（查询图生成）</li></ul><h2 id="研究目标">2.2 研究目标</h2><ul><li>提高 staged query graph generation method 的灵活性，以使其适应于多跳关系的问题</li><li>多跳关系问题处理的最关键的挑战是如何限制搜索空间</li><li>文中希望在查询图生成过程中同时引入约束和扩展关系路径，来更加有效的减少搜索空间</li></ul><h1 id="个人总结">3. 个人总结</h1><h2 id="优点">3.1 优点</h2><ul><li>使用强化学习来学习 staged query graph generation method 中动作的选择以及模型的参数</li><li>使用 beam search 来保存每阶段的 <span class="math inline">\(Top-K\)</span> 的查询图</li><li>每一步查询图扩展后，都进行一次查询图的评估，来缩小搜索空间</li></ul><h2 id="不足">3.2 不足</h2><ul><li>每迭代一次查询图扩展过程，就需要预测一次 score 值，也导致了训练与预测过程的效率比较低</li></ul><h1 id="问题定义">4. 问题定义</h1><ul><li>已知<ul><li>一个知识图谱 <span class="math inline">\(\mathcal{K} = \{ (h,r,t) \}\)</span>，<span class="math inline">\(h,t \in \mathcal{E}\)</span>，<span class="math inline">\(r \in \mathcal{R}\)</span></li><li>一个问句 <span class="math inline">\(Q\)</span></li></ul></li><li>问句查询图中 4 种类型的节点的定义如下：<ul><li>grounded entity。存在在知识图谱中的实体</li><li>existential variable。一个变量，代表存在在知识图谱中的不确定的实体</li><li>lambda variable。一个变量，代表待求的答案实体</li><li>aggregation function。聚合函数，比如 <span class="math inline">\(\mathop{\arg\min}\)</span> 或 <span class="math inline">\(\text{count}\)</span> 等，用来处理实体的集合</li></ul></li></ul><h1 id="方法">5. 方法</h1><h2 id="原始-staged-query-graph-generation-method-的步骤">5.1 原始 staged query graph generation method 的步骤</h2><ol style="list-style-type: decimal"><li>从问句中的一个 grounded entity 出发（此处的 grounded entity 也称作 topic entity），获得一个核心关系路径（core relation path，或基本查询图，basic query graph）。该核心关系路径连接了 topic entity 以及一个 lambda variable。现存的方法将核心关系路径中的关系数目限制为 1</li><li>在问句中识别约束（约束可能为一个 grounded entity、一个聚合函数以及一个关系），同时将约束附加在查询图上</li><li>针对上述过程生成的所有可能的候选查询图，评估其与问句的相似度</li><li>使用相似度最高的查询图，获取答案实体</li></ol><h2 id="查询图生成方法">5.2 查询图生成方法</h2><ul><li><p><strong>迭代地使用 beam search 来生成查询图</strong></p><ul><li>假设在第 <span class="math inline">\(t\)</span> 次迭代时，产生 <span class="math inline">\(K\)</span> 个查询图 <span class="math inline">\(\mathcal{G}_t\)</span></li><li>在第 <span class="math inline">\(t+1\)</span> 次迭代时，对 <span class="math inline">\(\mathcal{G}_t\)</span> 中的每个查询图 <span class="math inline">\(g\)</span>，选取动作集合中的动作来扩展查询图，得到 <span class="math inline">\(\mathcal{G}&#39;_{t+1}\)</span>。<ul><li>动作集合中包含 3 个动作：<span class="math inline">\(\{\textit{extend, connect, aggregate}\}\)</span><ul><li><span class="math inline">\(\textit{extend}\)</span>：增加一个在知识图谱中已存的关系到查询图中。当当前的查询图只有一个 topic entity 时，增加一个在知识图谱中连接到 topic entity 的关系 <span class="math inline">\(r\)</span> 到路径中，同时增加一个 lambda variable；当当前查询图中有一个 lambda variable <span class="math inline">\(x\)</span> 时，将 <span class="math inline">\(x\)</span> 替换为一个 <strong>existential variable</strong> <span class="math inline">\(y\)</span>，其次在知识图谱中查询所有可能的 <span class="math inline">\(y\)</span> 的实体集合，然后找到一个连接于这些实体的关系 <span class="math inline">\(r\)</span>，同时将 <span class="math inline">\(r\)</span> 连接到 <span class="math inline">\(y\)</span> 上，并将 <span class="math inline">\(r\)</span> 另一侧的变量变为 lambda variable</li><li><span class="math inline">\(\textit{connect}\)</span>：将一个 <strong>grounded entity</strong> 连接到 lambda variable 或 existential variable；关系的添加，通过执行当前查询图，获得当前连接到的 variable 和 待添加的grounded entity 之间的所有可能关系</li><li><span class="math inline">\(\textit{aggregate}\)</span>：通过预定义的词典来实现聚合函数的检测；将获得的聚合函数作为一个新的节点连接到 lambda variable 或 existential variable 上</li></ul></li></ul><div class="figure"><img src="/2020/06/26/Query-Graph-Generation-for-Answering-Multi-hop-Complex-Questions-from-Knowledge-Bases/action.png" alt="action"><p class="caption">action</p></div><ul><li>每次扩展 <span class="math inline">\(g\)</span> 时，只增加一个节点以及一个边</li></ul></li><li>使用一个 scoring function 来对 <span class="math inline">\(\mathcal{G}&#39;_{t+1}\)</span> 中的查询图进行排序</li><li>选取前 <span class="math inline">\(K\)</span> 个查询图组成 <span class="math inline">\(\mathcal{G}_{t+1}\)</span></li><li><p>直到在 <span class="math inline">\(\mathcal{G}_{t+1}\)</span> 中没有比 <span class="math inline">\(\mathcal{G}_{t}\)</span> 中的查询图的 score 更高的查询图时，迭代停止</p></li></ul></li></ul><h2 id="查询图排序">5.3 查询图排序</h2><ul><li>相当于上一节中的 scoring function</li><li>使用一个 7 维的特征向量来表示 <span class="math inline">\(g\in \mathcal{G}&#39;_t\)</span> 与 <span class="math inline">\(Q\)</span> 的相似情况<ul><li>基于 BERT 的语义匹配模型的输出的 score<ul><li>根据查询图生成过程的动作序列，将 <span class="math inline">\(g\)</span> 转化为一个 token 序列（token 序列中为实体和关系的文本描述，忽略 variable）。比如上一节的图 2(a) 中的序列为 (the, jeff, probst, show,nominated, for, nominee)</li><li>将查询图的序列好问句序列 concatenate 起来，使用 [CLS] token 来分割（为什么不使用 [SEP] 来分割），形成一个序列</li><li>而后在 BERT 的最上层获得一个 score 值</li></ul></li><li>查询图中所有 grounded entity 的累积 entity linking score</li><li>查询图中所有 grounded entity 的数目</li><li>查询图中所有 entity type 的数目</li><li>查询图中所有 temporal expression 的数目</li><li>查询图中所有 superlatives 的数目</li><li>查询图可以得到的 answer entities 的数目</li></ul></li><li>将这 7 维的向量输入到一个全连接层中，后面接上一个 softmax 函数来获得 <span class="math inline">\(p(g|Q)\)</span></li></ul><h2 id="训练过程">5.4 训练过程</h2><ul><li>训练过程只使用了（question, answers）对，并没有使用 ground truth query graphs（标注的真实的查询图）</li><li>使用 REINFORCE algorithm <a href="#%5B1%5D">[1]</a> 来训练模型的参数</li><li>使用预测的答案的 F1 score 来作为 reward</li></ul><h2 id="实验设置">5.5 实验设置</h2><ul><li>对于 ComplexWebQuestions 的数据集的 <strong>named entity linking</strong>，使用<a href="https://developers.google.com/knowledge-graph" target="_blank" rel="noopener">现存的工具</a>；对于其他两个数据集，使用已经抽取的 topic entities</li><li>对于 <strong>entity type linking</strong>，使用问句和它们对应的答案来训练一个 linking model</li><li>对于 <strong>temporal expressions 和 superlative linking</strong>，使用正则表达式以及 superlative word list（词典）的方式来抽取</li></ul><div class="figure"><img src="/2020/06/26/Query-Graph-Generation-for-Answering-Multi-hop-Complex-Questions-from-Knowledge-Bases/results.png" alt="results"><p class="caption">results</p></div><h1 id="论文讨论与总结">6. 论文讨论与总结</h1><ul><li>误差分析：<ul><li>65% 的误差来自于查询图的错误预测。其中一些关系很难检测到（比如缩写导致难以理解，如果训练集中没有，则可能需要引入外部的知识）</li><li>27% 的误差来自于 topic linking 的错误（包括 named entity linking、entity type linking、temporal expressions 和 superlative linking 的错误）</li></ul></li></ul><h1 id="关键参考文献">7. 关键参考文献</h1><p><a id="[1]">[1]</a> Rajarshi Das, Shehzaad Dhuliawala, Manzil Zaheer, Luke Vilnis, Ishan Durugkar, Akshay Krishnamurthy, Alex Smola, and Andrew McCallum. 2018. Go for a walk and arrive at the answer: Reasoning over paths in knowledge bases using reinforcement learning. In International Conference on Learning Representations.</p><ul><li><strong>staged query graph generation method</strong></li></ul><p>[2] Wen-tau Yih, Ming-Wei Chang, Xiaodong He, and Jianfeng Gao. 2015. Semantic parsing via staged query graph generation: Question answering with knowledge base. In Proceedings of the ACL-IJCNLP, pages 1321–1331.</p><p>[3] Junwei Bao, Nan Duan, Zhao Yan, Ming Zhou, and Tiejun Zhao. 2016. Constraint-based question answering with knowledge graph. In Proceedings of the COLING, pages 2503–2514.</p><p>[4] Kangqi Luo, Fengli Lin, Xusheng Luo, and Kenny Zhu. Knowledge base question answering via encoding of complex query graphs. In Proceedings of the EMNLP, pages 2185–2194.</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
          <category> 期刊或会议 </category>
          
          <category> ACL </category>
          
          <category> ACL2020 </category>
          
          <category> 领域 </category>
          
          <category> 知识图谱 </category>
          
          <category> 知识图谱问答 </category>
          
          <category> 方法 </category>
          
          <category> 语义解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱问答 </tag>
            
            <tag> 知识图谱 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Improving Multi-hop Question Answering over Knowledge Graphs using Knowledge Base Embeddings</title>
      <link href="/2020/06/26/Improving-Multi-hop-Question-Answering-over-Knowledge-Graphs-using-Knowledge-Base-Embeddings/"/>
      <url>/2020/06/26/Improving-Multi-hop-Question-Answering-over-Knowledge-Graphs-using-Knowledge-Base-Embeddings/</url>
      
        <content type="html"><![CDATA[<h1 id="文章信息">1. 文章信息</h1><ul><li>Saxena, Apoorv, Aditay Tripathi, and Partha Talukdar. &quot;Improving Multi-hop Question Answering over Knowledge Graphs using Knowledge Base Embeddings.&quot;</li><li>ACL2020</li><li>MetaQA 数据集与 WebQuestionsSP 数据集</li><li><a href="https://github.com/malllabiisc/EmbedKGQA" target="_blank" rel="noopener">github</a></li></ul><h1 id="研究领域与目标">2. 研究领域与目标</h1><h2 id="研究领域">2.1 研究领域</h2><ul><li>基于知识图谱的问答系统构建</li></ul><h2 id="研究目标">2.2 研究目标</h2><ul><li>处理不完备知识图谱，导致问题的回答需要增加 hop 才可以搜索到答案的情况</li><li>处理多跳知识图谱问答</li></ul><h1 id="个人总结">3. 个人总结</h1><h2 id="优点">3.1 优点</h2><ul><li>引入知识图谱嵌入处理多跳知识图谱问答问题。</li><li>将问句当做关系，统一问句表达向量与关系向量的向量空间，进而<strong>统一知识图谱嵌入与问句答案预测的得分函数和损失函数</strong></li></ul><h2 id="不足与可能的改进方向">3.2 不足与可能的改进方向</h2><ul><li>将问句编码为一个单一的向量，包含噪声且表达能力弱<ul><li>是否可以尝试将问句编码为路径？<ul><li>PTransE</li></ul></li></ul></li><li>无法处理带有约束和聚合函数的复杂问句<ul><li>是否可以尝试将基于语义解析的方法与该方法结合？<ul><li>staged query graph generation method</li></ul></li></ul></li><li>限制了 hop 数<ul><li>同样是否可以使用 staged query graph generation method？</li></ul></li></ul><h1 id="问题定义">4. 问题定义</h1><ul><li>已知<ul><li>一个知识图谱 $     $ ，其中的三元组表示为 $ (h, r, t) $ ，其中 $ h, t  $ ，$ r  $</li><li>一个问句 <span class="math inline">\(q\)</span></li><li>问句中的一个 topic entity <span class="math inline">\(e_h \in \mathcal{E}\)</span></li></ul></li><li>目标<ul><li>在知识图谱 <span class="math inline">\(\mathcal{K}\)</span> 中抽取一个可以正确回答问句 <span class="math inline">\(q\)</span> 的实体 <span class="math inline">\(e_t \in \mathcal{E}\)</span></li></ul></li></ul><h1 id="方法">5. 方法</h1><h2 id="知识图谱嵌入">5.1 知识图谱嵌入</h2><ul><li>文中知识图谱嵌入选用的是 ComplEx embedding <a href="#%5B1%5D">[1]</a>，其 triple scoring function 表示为 <span class="math inline">\(\phi(h,r,t)\)</span></li></ul><h2 id="问句编码">5.2 问句编码</h2><ul><li>使用 RoBERTa 编码问句，然后再使用 4 层的使用 ReLU 为激活函数的全连接层将问句投影到复数空间，获得问句表达 <span class="math inline">\(e_q \in \mathbb{C}^d\)</span></li><li><strong>问句编码的学习与训练过程</strong><ul><li>文中<strong>将问句编码的学习当做一个二分类问题</strong>，正确的答案标签为 1，错误答案的标签为0（当实体总数很大时，使用了 label smoothing）</li><li>给定一个问句 <span class="math inline">\(q\)</span>，问句中的一个 topic entity <span class="math inline">\(e_h \in \mathcal{E}\)</span>，以及真实答案集合 <span class="math inline">\(\mathcal{A} \subseteq \mathcal{E}\)</span>，文中希望学习一个问句编码来实现以下的目标</li></ul><p><span class="math display">\[\phi(e_h, e_q, e_a) &gt; 0 \quad \forall a \in \mathcal{A} \\\phi(e_h, e_q, e_\bar{a}) &lt; 0 \quad \forall \bar{a} \notin \mathcal{A}\]</span></p><ul><li>因此文中在 scoring function 后，使用了 sigmoid 激活函数</li><li>然后最小化二元交叉熵损失函数</li></ul></li></ul><h2 id="答案选择">5.3 答案选择</h2><ul><li>文中使用两个 score function 的组合来进行最终的答案实体选择</li><li>衡量 <strong>topic entity、问句与候选答案实体的分布相似度</strong>的 score：$ (e_h, e_q, e_{a'}) $</li><li>衡量<strong>关系匹配程度</strong>的 score<ul><li>给定问句，来对问句所匹配的关系进行排名</li><li>同样使用 RoBERTa 编码问句，然后使用 dot 相似度评估问句与关系之间的相似程度，并对关系进行排名</li></ul><span class="math display">\[h_q = \text{RoBERTa(q)} \\S(r,q) = \text{sigmoid}(h_q^T h_r)\]</span><ul><li>选取 <span class="math inline">\(S(r,q)\)</span> 大于 0.5 的所有关系，作为可能的关系集合 <span class="math inline">\(\mathcal{R}_a\)</span> 。同时找到 <span class="math inline">\(h\)</span> 和 <span class="math inline">\(a&#39;\)</span> 之间的最短路径上的关系的集合 <span class="math inline">\(\mathcal{R}_{a&#39;}\)</span></li><li>关系匹配程度的 score 定义为：<span class="math inline">\(\text{RelScore}_{a&#39;} = |\mathcal{R} \cap \mathcal{R}_{a&#39;}|\)</span></li></ul></li><li>最终 entity 的选择方式为</li></ul><p><span class="math display">\[e_{ans} = \mathop{\arg\max}_{a&#39;\in \mathcal{E}}  \phi(e_h,e_q,e_{a&#39;}) + \gamma * \text{RelScore}_{a&#39;}\]</span></p><h2 id="实验设置与技巧">5.4 实验设置与技巧</h2><ul><li>针对 WebQuestionsSP 数据集，对 Freebase 中的事实进行简化，只保留了所有在问句中出现的 entity 的 2-hop 范围内的事实，同时只保留了包含数据集中出现的关系的事实。</li><li>对不完备知识图谱的模拟实验中，通过随机去除一半的事实来实现</li><li>评估 topic entity 和 answer entity 之间没有直接的路径，然后却有一定的信息来获得答案。文中通过删除知识图谱中的直接的路径的三元组来实现</li><li>在 MetaQA 数据集上的表现</li></ul><div class="figure"><img src="/2020/06/26/Improving-Multi-hop-Question-Answering-over-Knowledge-Graphs-using-Knowledge-Base-Embeddings/metaqa" alt="MetaQA"><p class="caption">MetaQA</p></div><ul><li>在 WebQuestionsSP 数据集上的表现</li></ul><div class="figure"><img src="/2020/06/26/Improving-Multi-hop-Question-Answering-over-Knowledge-Graphs-using-Knowledge-Base-Embeddings/webqsp.png" alt="WebQuestionsSP"><p class="caption">WebQuestionsSP</p></div><h1 id="关键参考文献">6. 关键参考文献</h1><p><a id="[1]">[1]</a> Theo Trouillon, JohannesWelbl, Sebastian Riedel, ´ Eric Gaussier, and Guillaume Bouchard. 2016. Complex embeddings for simple link prediction. In International Conference on Machine Learning, pages 2071–2080.</p><p>[2] Yuyu Zhang, Hanjun Dai, Zornitsa Kozareva, Alexander J Smola, and Le Song. 2018. Variational reasoning for question answering with knowledge graph. In Thirty-Second AAAI Conference on Artificial Intelligence.</p><p>[3] Haitian Sun, Tania Bedrax-Weiss, and William W Cohen. 2019a. Pullnet: Open domain question answering with iterative retrieval on knowledge bases and text. arXiv preprint arXiv:1904.09537.</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
          <category> 期刊或会议 </category>
          
          <category> ACL </category>
          
          <category> ACL2020 </category>
          
          <category> 领域 </category>
          
          <category> 知识图谱 </category>
          
          <category> 知识图谱问答 </category>
          
          <category> 方法 </category>
          
          <category> 图嵌入算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱问答 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识图谱基础知识</title>
      <link href="/2020/06/25/knowledge-graph-book/"/>
      <url>/2020/06/25/knowledge-graph-book/</url>
      
        <content type="html"><![CDATA[<h1 id="知识图谱概述">1. 知识图谱概述</h1><ul><li>从结构化数据库中获取知识一般使用现有的<strong>D2R工具</strong>，如 Triplify、D2RServer、OpenLink、SparqlMap、Ontop等</li><li>知识融合过程中，可能存在模式层的融合，即本体融入本题库以及新旧本体的融合。如此带来了共识模式的演化。常见的<strong>本体演化管理框架</strong>有KAON、Conto-diff、OntoView</li><li>W3C的RDF的数据模型：三元组，逻辑结构包含主语、谓语、宾语</li><li>知识图谱的主要<strong>数据模型</strong>有RDF图和属性图两种；知识图谱<strong>查询语言</strong>可以分为声明式和导航式<ul><li>RDF三元组库（数据库）数据模型为RDF图，查询语言为SPARQL，SPARQL为声明式查询语言</li><li>图数据库是数据库领域为更好地存储和管理图模型数据而开发的数据库管理系统，其数据模型为属性图，声明式查询语言有：Cypher（Neo4j）、PGQL（Oracle）、G-Core（LDBC）</li></ul></li><li><strong>语义网络（Semantic Network）与语义网（Semantic Web）</strong><ul><li>语义网络由认知科学家于 1960 年提出，关注于知识的表示和推理</li><li>语义网由计算机科学家于1998年提出，目标是把基于文本链接的万维网转化成基于实体链接的语义网，语义网的提出为知识表示提供了一个很好的应用场景</li></ul></li><li><strong>深度学习的局限性</strong>，是机器从感知智能向认知智能迁跃过程中必须解决的问题。认知智能要求机器具备推理和抽象能力，需要模型能够利用先验知识，总结出人可理解、模型可复用的知识。整体上需要从数据计算转向知识计算，知识图谱显得必不可少。 <code>~Page 435~</code><ul><li>缺乏可解释性</li><li>常识缺失</li><li>缺乏语义理解</li><li>依赖大量样本数据</li></ul></li><li>大数据通过识别有用的关联关系来分析一个现象，而不是揭示其内部的运作机制，因此基于相关分析的预测是大数据的核心 <code>~Page 452~</code></li><li>基于知识图谱的领域建模、基于规模化大数据的处理能力、针对半结构化标签型数据的分析预测算法三者的结合，是人工智能的优势所在 <code>~Page 453~</code></li><li>知识库可以分为两种类型，一种是以 Freebase，Yago2 为代表的 <strong>Curated KBs</strong>，主要从维基百科和 WordNet 等知识库中抽取大量的实体及实体关系，像是一种结构化的维基百科。另一种是以 Stanford OpenIE，和 Never-Ending Language Learning (NELL) 为代表的 <strong>Extracted KBs</strong>，直接从上亿个非结构化网页中抽取实体关系三元组。<ul><li><strong>Extracted KBs</strong> 与 <strong>Curated KBs</strong> 相比，得到的知识更加<strong>多样性</strong>，但同时精确度要低于 Curated KBs，因为实体关系和实体更多的是<strong>自然语言</strong>的形式，如“奥巴马出生在火奴鲁鲁。” 可以被表示为（“Obama”, “was also born in”, “ Honolulu”）。</li></ul></li></ul><hr><h1 id="知识表示与建模">2. <a id="2">知识表示与建模</a></h1><ul><li><strong>知识表示的五大用途和特点</strong>：<ul><li>客观事物的机器标示。定义客观事物的机器指代</li><li>一组本体约定好概念模型。定义描述客观事物的概念和类别体系</li><li>知识推理的表示基础。提供机器推理的模型与方法</li><li>用于高效计算的数据结构。</li><li>人可理解的机器语言。</li></ul></li></ul><h2 id="早期知识表示方法-page-43">2.1 早期知识表示方法 <code>~Page 43~</code></h2><h3 id="一阶谓词逻辑一阶逻辑">2.1.1 一阶谓词逻辑（一阶逻辑）</h3><ul><li>公理系统的标准形式逻辑，不同于命题逻辑，支持谓词和量词（全称量词和存在量词）</li></ul><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">﹁图灵奖得主（<span class="symbol">x</span>）  # 否定公式</span><br><span class="line">若<span class="symbol">x</span>为John MaCarthy，图灵奖得主（<span class="symbol">x</span>）</span><br></pre></td></tr></table></figure><h3 id="霍恩子句和霍恩逻辑">2.1.2 霍恩子句和霍恩逻辑</h3><ul><li>是一阶逻辑的子集，带有最多一个肯定文字的子句</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">﹁p_1 ∨...∨﹁p_n∨q   ==&gt;   <span class="function"><span class="params">(p_1 ∧...∧p_n)</span> -&gt;</span> q</span><br></pre></td></tr></table></figure><ul><li>霍恩逻辑规则由原子公式构成</li></ul><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B_1 ∧...∧B_n -&gt; H  # H为头原子公式，B为体原子公式，B可以没有</span><br><span class="line"></span><br><span class="line">∀<span class="symbol">x</span>,<span class="symbol">y</span>:IsDirectorOf(<span class="symbol">x</span>,<span class="symbol">y</span>) ==&gt; BeDirectedBy(<span class="symbol">y</span>,<span class="symbol">x</span>)</span><br></pre></td></tr></table></figure><h3 id="语义网络">2.1.3 语义网络</h3><ul><li>在形式上是一个带标识的有向图，每个节点可以带有若干属性</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(节点 <span class="number">1</span>，联想弧，节点 <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>无形式化语法</strong>。相同知识，可以表示为多种不同的语义网络</li></ul><h3 id="框架">2.1.4 框架</h3><ul><li>框架是一种描述对象属性的数据结构，其中类是知识表示的基本单位</li><li>槽表示对象的一个属性，侧面表示属性的一个方面。槽和侧面都可以有属性值，称为槽值和侧面值</li><li></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;框架名&gt;</span><br><span class="line">槽名 A       侧面名 A_1      值 A_&#123;<span class="number">11</span>&#125;, 值 A_&#123;<span class="number">12</span>&#125;...</span><br><span class="line">侧面名 A_2      值 A_&#123;<span class="number">21</span>&#125;, 值 A_&#123;<span class="number">22</span>&#125;...</span><br><span class="line">槽名 B       侧面名 B_1      值 B_&#123;<span class="number">11</span>&#125;, 值 B_&#123;<span class="number">12</span>&#125;...</span><br><span class="line">侧面名 B_2      值 B_&#123;<span class="number">21</span>&#125;, 值 B_&#123;<span class="number">22</span>&#125;...</span><br><span class="line">约束条件</span><br><span class="line">约束条件 <span class="number">1</span></span><br><span class="line">约束条件 <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="描述逻辑">2.1.5 描述逻辑</h3><ul><li>是一阶逻辑的一个可判定子集</li><li>描述逻辑可以被看成是利用一阶逻辑对语义网络和框架进行形式化后的产物</li><li>描述逻辑一般支持一元谓词（类）和二元谓词（关系）</li><li>同时具有很强的表达能力和可判定性，但不支持显示使用变量，不能够任意使用量化</li><li>描述逻辑语言是大多数本体语言（如 OWL）的理论基础</li><li>一个描述逻辑表示知识库主要由TBox和ABox两部分组成。TBox定义了特定知识领域的结构并包含一系列公理，可以通过已有概念构成新的概念。ABox包含了TBox中概念的实例</li></ul><div class="figure"><img src="/2020/06/25/knowledge-graph-book/description_logic.jpg" alt="描述逻辑"><p class="caption">描述逻辑</p></div><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="symbol">x</span>|Student(<span class="symbol">x</span>)&#125;,&#123;<span class="symbol">x</span>|Children(<span class="symbol">x</span>)&#125;</span><br><span class="line">&#123;&lt;<span class="symbol">x</span>,<span class="symbol">y</span>&gt;|Friend(<span class="symbol">x</span>,<span class="symbol">y</span>)&#125;,&#123;&lt;<span class="symbol">x</span>,<span class="symbol">y</span>&gt;|Couple(<span class="symbol">x</span>,<span class="symbol">y</span>)&#125;</span><br></pre></td></tr></table></figure><h2 id="语义网知识表示框架">2.2 语义网知识表示框架</h2><h3 id="rdf">2.2.1 RDF</h3><ul><li>RDF 是 W3C 的 RDF 工作组制定的关于知识图谱的国际标准，是 W3C 一系列语义网标准的核心</li><li>语义网的基础数据模型为 RDF</li><li>RDF 采用<strong>开放世界假设</strong>，RDF 图谱里的知识可能是不完备的。可以分布式存储，以及实现分布式定义的知识的自动合并</li><li><strong>实现开放链接数据五星原则的四个步骤</strong><ul><li>使用 URIs（统一资源标识符） 对事物命名</li><li>使用 HTTP URIs，以方便搜索</li><li>使用 RDF 描述事物并提供 SPARQL 端点，以方便对 RDF 图谱查询</li><li>链接不同的图谱（例如通过 owl:sameAs），以方便数据重用</li></ul></li><li>在 RDF 中，知识总是以三元组的形式出现。三元组中的主语是一个个体，个体是类的实例；谓语是一个属性，连接两个个体或一个个体和一个数据类型的实例；宾语可以是一个个体，也可以是一个<strong>数据类型的实例</strong>（<code>&quot;05-10-2012&quot;^xsd:date</code>）</li><li>三元组中的主谓宾都有一个<strong>全局标识 URI</strong> ，全局标识可以简化成前缀 URI。同时 RDF 允许没有全局标识的空白节点，前缀为 &quot;_&quot;</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">http:</span>//ex<span class="meta">.org</span>/jeff  <span class="meta"># 实体为jeff</span></span><br><span class="line"><span class="symbol">http:</span>//ex<span class="meta">.org</span>/schema<span class="meta">#speaker  # 关系为speaker</span></span><br><span class="line"><span class="symbol">ex:</span>jeff  <span class="meta"># 简化前缀</span></span><br><span class="line"><span class="symbol">_:</span><span class="built_in">x</span>  <span class="meta"># 空白节点</span></span><br></pre></td></tr></table></figure><ul><li><strong>RDF 是抽象的数据模型，支持不同的序列化格式</strong>，如： RDF/XML、Turtle、N-Triples、N-Quads、TriG、TriX</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#  RDF/XML</span><br><span class="line">&lt;rdf:RDF xmlns:<span class="keyword">ex</span>-schema=http:<span class="comment">//ex.org/schema#&gt;</span></span><br><span class="line"># 主语，若缺少rdf:<span class="keyword">about</span>属性，则此元素表示空白节点</span><br><span class="line"> &lt;rdf:Description rdf:<span class="keyword">about</span>=<span class="string">"http://ex.org/ibm_talk"</span>&gt;      </span><br><span class="line">   &lt;<span class="keyword">ex</span>-schema:speaker rdf:resource=<span class="string">"http://ex.org/jeff"</span>&gt;     # 谓语和宾语</span><br><span class="line">   &lt;<span class="keyword">ex</span>-schema:theme rdf:resource=<span class="string">"http://ex.org/KG"</span>&gt;</span><br><span class="line">&lt;/rdf:RDF&gt;</span><br><span class="line"></span><br><span class="line">#  Turtle</span><br><span class="line">@prefix <span class="keyword">ex</span>: &lt;http:<span class="comment">//ex.org/&gt;.</span></span><br><span class="line">@prefix <span class="keyword">ex</span>-schema: &lt;http:<span class="comment">//ex.org/schema#&gt;</span></span><br><span class="line"># 空白节点为 _:ibm_talk</span><br><span class="line"><span class="keyword">ex</span>:ibm_talk</span><br><span class="line"> <span class="keyword">ex</span>-schema:speaker <span class="keyword">ex</span>:jeff;</span><br><span class="line"> <span class="keyword">ex</span>-schema:theme <span class="keyword">ex</span>:KG.</span><br><span class="line"></span><br><span class="line">#  <span class="keyword">N</span>-Triples</span><br><span class="line">&lt;http:<span class="comment">//ex.org/ibm_talk&gt;</span></span><br><span class="line">  &lt;http:<span class="comment">//ex.org/schema#speaker&gt;</span></span><br><span class="line">  &lt;http:<span class="comment">//ex.org/jeff&gt;</span></span><br><span class="line">&lt;http:<span class="comment">//ex.org/ibm_talk&gt;</span></span><br><span class="line">  &lt;http:<span class="comment">//ex.org/schema#theme&gt;</span></span><br><span class="line">  &lt;http:<span class="comment">//ex.org/KG&gt;</span></span><br></pre></td></tr></table></figure><h3 id="rdfs">2.2.2 RDFS</h3><ul><li><p><strong>RDF 无法区分类和对象，也无法定义和描述类的关系/属性</strong>，缺乏抽象能力，无法对同一个类别的事物进行定义和描述</p></li><li>RDF Schema（RDF 模式，简称 RDFS），提供了对类和属性（谓语）的简单描述。更丰富的定义需要用到 OWL 本体描述语言</li><li><p>RDFS 提供了最基本的对类好属性的描述元语</p></li></ul><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">rdf:type        # 制定个体的类</span><br><span class="line">rdfs:subClassOf       # 制定类的父类</span><br><span class="line">rdfs:subPropertyOf     # 制定属性的父属性</span><br><span class="line">rdfs:domain          # 制定属性的定义域</span><br><span class="line">rdfs:range     # 制定属性的值域</span><br><span class="line"></span><br><span class="line"># RDF/XML</span><br><span class="line">&lt;rdf:RDF xmlns:rdf= "http://www.w3.org/1999/02/22-rdf-syntax-ns#" </span><br><span class="line"><span class="code"> xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;rdf:Description rdf:ID="animal"&gt;</span><br><span class="line"><span class="code">  &lt;rdf:type rdf:resource="http://www.w3.org/2000/01/rdf-schema#Class"/&gt;</span></span><br><span class="line">&lt;/rdf:Description&gt;</span><br><span class="line"></span><br><span class="line">&lt;rdf:Description rdf:ID="horse"&gt;</span><br><span class="line"><span class="code">  &lt;rdf:type rdf:resource="http://www.w3.org/2000/01/rdf-schema#Class"/&gt;</span></span><br><span class="line"><span class="code">  &lt;rdfs:subClassOf rdf:resource="#animal"/&gt;</span></span><br><span class="line">&lt;/rdf:Description&gt;</span><br><span class="line"></span><br><span class="line">&lt;/rdf:RDF&gt;</span><br><span class="line"></span><br><span class="line"># Turtle:</span><br><span class="line">@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .</span><br><span class="line">@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .</span><br><span class="line">@prefix : &lt;http://www.kg.com/ontology/&gt; .</span><br><span class="line"></span><br><span class="line"># 这里我们用词汇rdfs:Class定义了“人”和“地点”这两个类。</span><br><span class="line"><span class="meta">:Person rdf:type</span> rdfs:Class.</span><br><span class="line"><span class="meta">:Place rdf:type</span> rdfs:Class.</span><br><span class="line"></span><br><span class="line"># rdfs当中不区分数据属性和对象属性，词汇rdf:Property定义了属性，即RDF的“边”。</span><br><span class="line"><span class="meta">:chineseName rdf:type</span> rdf:Property;</span><br><span class="line"><span class="code">        rdfs:domain :Person;</span></span><br><span class="line"><span class="code">        rdfs:range xsd:string .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">:career rdf:type</span> rdf:Property;</span><br><span class="line"><span class="code">        rdfs:domain :Person;</span></span><br><span class="line"><span class="code">        rdfs:range xsd:string .</span></span><br></pre></td></tr></table></figure><h3 id="owlweb-ontology-language">2.2.3 OWL（Web Ontology Language）</h3><ul><li><strong>RDF（S）语义表达能力弱，还缺少常用的特征</strong>：<ul><li>对于局部值域的属性定义。<code>rdfs:range</code> 是全局性的，无法说明某一属性应用于具体类时具有的特殊值域限制</li><li>类、属性、个体的等价性。无法声明两个类或多个类、属性、个体是等价还是不等价</li><li>不相交类的定义。只能声明子类关系，无法说明子类之间的不相交性（男人和女人的类别不相交）</li><li>基数约束。对某属性值可能或必须的取值范围进行约束（一个人有双亲，包括了两个人）</li><li>关于属性特性的描述。声明属性的某些特性，如传递性、函数性、对称性以及一个属性是另一个属性的逆属性</li></ul></li><li>OWL 是 RDF（S）的扩展，作为在<strong>语义网上表示本体的推荐语言</strong></li><li><p>所有的 OWL 文档（Lite、DL、Full）都是一个 RDF 文档，所有的 RDF 文档都是一个 OWL Full 文档</p></li><li><p><strong>OWL 重要词汇</strong> <code>~Page 55~</code></p></li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">@prefix <span class="keyword">ow</span><span class="variable">l:</span> &lt;http://www.w3.org/<span class="number">2002</span>/<span class="number">07</span>/owl#&gt; .</span><br><span class="line">@prefix <span class="built_in">exp</span>: &lt;http://example.org&gt; .</span><br><span class="line"></span><br><span class="line"># 等价性声明</span><br><span class="line"><span class="keyword">ow</span><span class="variable">l:equivalentClass</span>  # 类等价</span><br><span class="line"><span class="keyword">ow</span><span class="variable">l:equivalentProperty</span>  # 属性等价</span><br><span class="line"><span class="keyword">ow</span><span class="variable">l:sameIndividualAs</span>  # 实例等价</span><br><span class="line"></span><br><span class="line"># 属性传递声明</span><br><span class="line"># 声明<span class="built_in">exp</span>:ancestor是一个传递关系，即<span class="keyword">a</span> <span class="built_in">exp</span>:ancestor <span class="keyword">b</span>，<span class="keyword">b</span> <span class="built_in">exp</span>:ancestor <span class="keyword">c</span>，则<span class="keyword">a</span> <span class="built_in">exp</span>:ancestor <span class="keyword">c</span></span><br><span class="line"><span class="built_in">exp</span>:ancestor rdf:<span class="built_in">type</span> <span class="keyword">ow</span><span class="variable">l:TransitiveProperty</span>  </span><br><span class="line"></span><br><span class="line"># 属性互逆声明</span><br><span class="line"><span class="built_in">exp</span>:ancestor <span class="keyword">ow</span><span class="variable">l:inverseOf</span> <span class="built_in">exp</span>:descendant</span><br><span class="line"></span><br><span class="line"># 属性函数性声明</span><br><span class="line"><span class="built_in">exp</span>:hasMother rdf:<span class="built_in">type</span> <span class="keyword">ow</span><span class="variable">l:FunctionalProperty</span>  # 一个生物只能有一个妈妈</span><br><span class="line"></span><br><span class="line"># 属性的对称性声明</span><br><span class="line"><span class="built_in">exp</span>:friend rdf:<span class="built_in">type</span> <span class="keyword">ow</span><span class="variable">l:SymmetricProperty</span></span><br><span class="line"></span><br><span class="line"># 属性的全称限定声明</span><br><span class="line"># 声明<span class="built_in">exp</span>:hasMother在主语属于<span class="built_in">exp</span>:Person类的条件下，宾语只能来自<span class="built_in">exp</span>:Women</span><br><span class="line"><span class="built_in">exp</span>:Person <span class="keyword">ow</span><span class="variable">l:allValuesFrom</span> <span class="built_in">exp</span>:Women</span><br><span class="line"><span class="built_in">exp</span>:Person <span class="keyword">ow</span><span class="variable">l:onProperty</span> <span class="built_in">exp</span>:hasMother</span><br><span class="line"></span><br><span class="line"># 属性的存在限定声明</span><br><span class="line"># 声明<span class="built_in">exp</span>:publishedIn在主语属于<span class="built_in">exp</span>:SemanticWebPaper类的条件下，宾语部分来自<span class="built_in">exp</span>:AAAI</span><br><span class="line"><span class="built_in">exp</span>:SemanticWebPaper <span class="keyword">ow</span><span class="variable">l:someValuesFrom</span> <span class="built_in">exp</span>:AAAI</span><br><span class="line"><span class="built_in">exp</span>:SemanticWebPaper <span class="keyword">ow</span><span class="variable">l:onProperty</span> <span class="built_in">exp</span>:publishedIn</span><br><span class="line"></span><br><span class="line"># 属性基数限定声明（宾语的个数）</span><br><span class="line"># 声明<span class="built_in">exp</span>:hasMother在主语属于<span class="built_in">exp</span>:Person类的条件下，宾语只能有一个</span><br><span class="line"><span class="built_in">exp</span>:Person <span class="keyword">ow</span><span class="variable">l:cardinality</span> <span class="string">"1"</span>^^xsd:integer</span><br><span class="line"><span class="built_in">exp</span>:Person <span class="keyword">ow</span><span class="variable">l:onProperty</span> <span class="built_in">exp</span>:hasMother</span><br><span class="line"></span><br><span class="line"># 相交类，声明一个类等价于两个类相交</span><br><span class="line"># _:tmp是临时资源，是rdf<span class="variable">s:Collection</span>类型，是一个容器，两个成员为<span class="built_in">exp</span>:Person和<span class="built_in">exp</span>:HasChildren。下述三元组说明<span class="built_in">exp</span>:Mother是<span class="built_in">exp</span>:Person和<span class="built_in">exp</span>:HasChildren的交集</span><br><span class="line"><span class="built_in">exp</span>:Mother <span class="keyword">ow</span><span class="variable">l:intersectionOf</span> _:tmp</span><br><span class="line">_:tmp rdf:<span class="built_in">type</span> rdf<span class="variable">s:Collection</span></span><br><span class="line">_:tmp rdf<span class="variable">s:member</span> <span class="built_in">exp</span>:Person</span><br><span class="line">_:tmp rdf<span class="variable">s:member</span> <span class="built_in">exp</span>:HasChildren</span><br><span class="line"></span><br><span class="line"><span class="keyword">ow</span><span class="variable">l:oneOf</span>     # 声明枚举类型</span><br><span class="line"><span class="keyword">ow</span><span class="variable">l:disjointWith</span>     # 声明两个类不相交</span><br><span class="line"><span class="keyword">ow</span><span class="variable">l:unionOf</span>      # 声明类的并运算</span><br><span class="line"><span class="keyword">ow</span><span class="variable">l:minCardinality</span>     # 声明最小基数限定</span><br><span class="line"><span class="keyword">ow</span><span class="variable">l:maxCardinality</span>     # 声明最大基数限定</span><br><span class="line"><span class="keyword">ow</span><span class="variable">l:InverseFunctionalProperty</span>    # 声明互反类具有函数特性</span><br><span class="line"><span class="keyword">ow</span><span class="variable">l:hasValue</span>    # 声明所约束类必有一个取值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 这个例子表示，白葡萄酒就是葡萄酒和白色物体的相交的集合</span><br><span class="line">&lt;<span class="keyword">ow</span><span class="variable">l:Class</span> rdf:ID=<span class="string">"WhiteWine"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">ow</span><span class="variable">l:intersectionOf</span> rdf:parseType=<span class="string">"Collection"</span>&gt; /*这是必须的，因为必须对集合操作*/</span><br><span class="line">    &lt;<span class="keyword">ow</span><span class="variable">l:Class</span> rdf:about=<span class="string">"#Wine"</span> /&gt;</span><br><span class="line">    &lt;<span class="keyword">ow</span><span class="variable">l:Restriction</span>&gt;</span><br><span class="line">      &lt;<span class="keyword">ow</span><span class="variable">l:onProperty</span> rdf:resource=<span class="string">"#hasColor"</span> /&gt;</span><br><span class="line">      &lt;<span class="keyword">ow</span><span class="variable">l:hasValue</span> rdf:resource=<span class="string">"#White"</span> /&gt;</span><br><span class="line">    &lt;/<span class="keyword">ow</span><span class="variable">l:Restriction</span>&gt;</span><br><span class="line">  &lt;/<span class="keyword">ow</span><span class="variable">l:intersectionOf</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">ow</span><span class="variable">l:Class</span>&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="知识存储">3. <a id="3">知识存储</a></h1><ul><li>语义万维网领域发展处专门存储 RDF 数据的三元组库；数据库领域发展出用于管理属性图的图数据库</li></ul><h2 id="知识图谱的图数据模型">3.1 知识图谱的图数据模型</h2><h3 id="rdf-图">3.1.1 RDF 图</h3><ul><li><p>RDF 是 W3C 制定的在语义万维网上表示和交换机器可理解信息的标准数据模型</p></li><li><p>一个 RDF 图定义为三元组的有限集合</p></li><li><p><strong>RDF 图对于节点和边上的属性没有内置的支持</strong>。</p><ul><li>节点属性可以用三元组表示，此时宾语称为字面量</li><li>边上的属性的表示利用 RDF 中叫做 具体化（reification） 的技术。该技术需要引入额外的点表示整个三元组，同时将边属性表示为以该节点为主语的三元组</li></ul></li></ul><p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ex</span><span class="selector-pseudo">:zhangsan</span> 参加 <span class="selector-tag">ex</span><span class="selector-pseudo">:graphdb</span></span><br><span class="line"></span><br><span class="line"># 引入 <span class="selector-tag">ex</span><span class="selector-pseudo">:participate</span> 节点</span><br><span class="line"><span class="selector-tag">ex</span><span class="selector-pseudo">:participate</span> <span class="selector-tag">rdf</span><span class="selector-pseudo">:subject</span> <span class="selector-tag">ex</span><span class="selector-pseudo">:zhangsan</span></span><br><span class="line"><span class="selector-tag">ex</span><span class="selector-pseudo">:participate</span> <span class="selector-tag">rdf</span><span class="selector-pseudo">:predicate</span> 参加</span><br><span class="line"><span class="selector-tag">ex</span><span class="selector-pseudo">:participate</span> <span class="selector-tag">rdf</span><span class="selector-pseudo">:object</span> <span class="selector-tag">ex</span><span class="selector-pseudo">:graphdb</span></span><br><span class="line"># 边属性添加</span><br><span class="line"><span class="selector-tag">ex</span><span class="selector-pseudo">:participate</span> 权重 0<span class="selector-class">.4</span></span><br></pre></td></tr></table></figure></p><h3 id="属性图">3.1.2 属性图</h3><ul><li>目前被图数据库业界采纳最广的一种图数据模型，由节点和边集组成</li><li>具有如下<strong>性质</strong>：<ul><li>每个节点有唯一的 id</li><li>每个节点有若干条出边和入边</li><li>每个节点有一组属性，每个属性是一个键值对</li><li>每条边有唯一的id</li><li>每条边具有一个头节点和一个尾结点</li><li>每条边具有一个标签，表示联系</li><li>每条边具有一组属性，每个属性是一个键值对</li></ul></li></ul><h2 id="知识图谱查询语言">3.2 <a id="3.2">知识图谱查询语言</a></h2><ul><li>RDF 图上的查询语言是 SPARQL；属性图上常用的查询语言是 Cypher 和 Gremlin；</li></ul><h3 id="sparql-rdf-图查询-page-59">3.2.1 SPARQL （RDF 图查询） <code>~Page 59~</code></h3><ul><li><p>声明式查询语言</p></li><li><p>查询过程中涉及到多个三元组模式，可以组成<strong>基本图模式（Basic Graph Pattern）查询</strong>，简称 BGP 查询，等价于图论中的子图同构或子图同态问题，所以 BGP 查询也称子图匹配查询。<code>~Page 86~</code></p></li><li><p><strong>基本组成</strong>：</p><ul><li>变量，以 <code>?</code> 或者 <code>$</code> 表示</li><li>三元组模板，在 <code>WHERE</code> 子句中列出的三元组模板，其中允许变量存在</li><li><code>SELECT</code> 子句指示查询目标变量</li></ul></li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PREFIX exp: http:&#x2F;&#x2F;www.example.org&#x2F;</span><br><span class="line">SELECT ?student</span><br><span class="line">WHERE &#123;</span><br><span class="line">?student exp:studies exp:CS328 .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>常见的<strong>查询算子</strong></p><ul><li><code>OPTIONAL</code> ：指这个算子覆盖范围的查询语句是可选的。如下若学生没有邮箱，则依然返回姓名，邮箱空缺</li></ul></li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PREFIX exp: http:&#x2F;&#x2F;www.example.org&#x2F;</span><br><span class="line">SELECT ?student ?email</span><br><span class="line">WHERE &#123;</span><br><span class="line">?student exp:studies exp:CS328 .</span><br><span class="line">OPTIONAL &#123;</span><br><span class="line">    ?student foaf:mbox ?email .</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code>* `FILTER`：指这个算子覆盖范围的查询用来过滤查询结果</code></pre><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT ?module ?name ?age</span><br><span class="line">WHERE &#123;</span><br><span class="line">?student exp:studies ?module .</span><br><span class="line">    ?student foaf:name ?name .</span><br><span class="line">OPTIONAL &#123;</span><br><span class="line">    ?student exp:age ?age .</span><br><span class="line">    FILTER (?age &gt; 25)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code>* `UNION`：将两个查询结果合并</code></pre><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT ?student ?email</span><br><span class="line">WHERE &#123;</span><br><span class="line">    ?student foaf:mbox ?email .</span><br><span class="line">    &#123;?student exp:studies exp:CS328&#125; UNION &#123;?student exp:studies exp:CS909&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>SPARQL 允许嵌套，即 <code>WHERE</code> 子句中包含 <code>SELECT</code> 子句</p></li><li><p><strong>属性路径机制</strong>，如下所示。<code>ex:knows*/ex:participate</code> 类似正则表达式，表示经过0条、1条或多条 <code>ex:knows</code> 边，再经过一条 <code>ex:participate</code> 边。<code>~Page 87~</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PREFIX ex: &lt;http:&#x2F;&#x2F;www.example.org&#x2F;&gt;</span><br><span class="line">SELECT ?name</span><br><span class="line">WHERE &#123;</span><br><span class="line">    ?p ex:participate ex:graphdb .</span><br><span class="line">    ?p ex:age 29 .</span><br><span class="line">    ?p ex:knows*&#x2F;ex:participate ?pr .</span><br><span class="line">    ?pr rdfs:label ?name .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cypher-属性图查询-page-87">3.2.2 Cypher （属性图查询） <code>~Page 87~</code></h3><ul><li>声明式语言</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MATCH (p:程序员)</span><br><span class="line">RETURN p</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查询边</span><br><span class="line">MATCH (:程序员) -[r]-&gt; (:项目 &#123;name: &#39;图数据库&#39;&#125;)</span><br><span class="line">RETURN r</span><br><span class="line">                     </span><br><span class="line">&#x2F;&#x2F; 多模式</span><br><span class="line">MATCH (:程序员) -[:认识]-&gt; (p:程序员), (p) -[:参加]-&gt; (pr:项目)</span><br><span class="line">WHERE p.年龄 &gt; 30</span><br><span class="line">RETURN pr.项目</span><br></pre></td></tr></table></figure><h3 id="gremlin属性图查询-page-89">3.2.3 Gremlin（属性图查询） <code>~Page 89~</code></h3><ul><li>是 Apache TinkerPop 图计算框架提供的属性图查询语言</li><li>Gremlin 为<strong>过程式语言，或导航式语言</strong>。用户使用 Gremlin 需要指明具体的导航步骤</li><li>Gremlin 更像是一种函数式的编程语言接口</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 列出图中所有节点的属性</span><br><span class="line">g.V</span><br><span class="line"></span><br><span class="line"># 边</span><br><span class="line">g.E</span><br><span class="line"></span><br><span class="line"># 查询从节点1出发的标签为“认识”的边</span><br><span class="line">g.v(1).outE(&#39;认识&#39;)</span><br><span class="line"></span><br><span class="line">g.v(1).out(&#39;认识&#39;).filter&#123;it.年龄 &gt; 30&#125;.out(&#39;参加&#39;).项目</span><br></pre></td></tr></table></figure><h2 id="知识图谱存储方案-page-91-page-20">3.3 知识图谱存储方案 <code>~Page 91 Page 20~</code></h2><ul><li>基于关系型数据库的存储方案通常能够适应<strong>千万到十亿三元组规模</strong>的管理；</li><li>对于一般在<strong>百万到上亿三元组</strong>的管理，使用稍高配置的单机系统和主流RDF三元组数据库（如 Jena、RDF4J、Virtuoso等）完全可以胜任；</li><li>对于<strong>几亿到几十亿以上</strong>的大规模 RDF 三元组，可以尝试部署具备分布式存储和查询能力的数据库系统（如商业版的 GraphDB 和 Blazegraph、开源的 JanusGraph等） <code>~Page 23 Page 120~</code></li><li><strong>构建领域知识图谱底层数据库有非常多的选择，从传统的关系数据库到 NoSQL，再到图数据库。</strong><code>~Page 456~</code><ul><li>数据库选型需要充分考虑领域数据自身的特点（以结构化数据为主，还是以非结构化数据为主），以及如何使用这些数据（例如是否经常需要沿知识图谱进行推理，推理路径长短等）<ul><li>通常来说，Neo4j 等图数据库擅长长链推理，但对单位基础数据的日常维护较弱</li><li>MongoDB、HBase 等 NoSQL 数据库擅长处理文本类非结构化数据库，对于传统数值型数据的很多处理则需要额外写代码维护</li><li>MySQL 等传统数据库擅长处理和维护结构化数据，在面对沿知识图谱进行推理等应用时，则需要比图数据库更多的代码量</li></ul></li></ul></li></ul><div class="figure"><img src="/2020/06/25/knowledge-graph-book/知识图谱存储方案.jpg" alt="存储方案"><p class="caption">存储方案</p></div><h3 id="基于关系数据库的存储方案">3.3.1 基于关系数据库的存储方案</h3><ul><li>继承了关系数据库的优势，成熟度较高</li></ul><h4 id="a.-三元组表">a. 三元组表</h4><ul><li>每个三元组存储为一行，在关系数据库中建立一张具有3列的表</li></ul><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">主语，谓语，宾语</span>)</span><br></pre></td></tr></table></figure><ul><li>三元组表的<strong>优势</strong>在于行维度上的灵活性，即存储模式不会随行的增加而变化</li><li>问题在于将知识图谱查询翻译为 SQL 查询后的三元组表<strong>自连接</strong>（如下），当三元组表规模较大时，多个自连接操作会使 SQL 查询性能低下</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SPARQL</span></span><br><span class="line">SELECT ?person</span><br><span class="line">WHERE &#123;</span><br><span class="line">?person <span class="keyword">born </span><span class="string">"1850"</span> .</span><br><span class="line">?person <span class="keyword">died </span><span class="string">"1934"</span> .</span><br><span class="line">?person founder ?company .</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># SQL</span></span><br><span class="line">SELECT <span class="built_in">t1</span>.主语</span><br><span class="line">FROM t AS <span class="built_in">t1</span>, t AS <span class="built_in">t2</span>, t AS <span class="built_in">t3</span></span><br><span class="line">WHERE</span><br><span class="line"><span class="built_in">t1</span>.主语 = <span class="built_in">t2</span>.主语 <span class="keyword">AND </span><span class="built_in">t2</span>.主语 = <span class="built_in">t3</span>.主语 <span class="keyword">AND </span><span class="built_in">t1</span>.谓语 = <span class="string">'born'</span> <span class="keyword">AND </span><span class="built_in">t1</span>.宾语 = <span class="string">'1850'</span></span><br><span class="line">  <span class="keyword">AND </span><span class="built_in">t2</span>.谓语 = <span class="string">'died'</span> <span class="keyword">AND </span><span class="built_in">t2</span>.宾语 = <span class="string">'1934'</span></span><br><span class="line">  <span class="keyword">AND </span><span class="built_in">t3</span>.谓语 = <span class="string">'founder'</span></span><br></pre></td></tr></table></figure><h4 id="b.-水平表">b. 水平表</h4><ul><li>每行存储知识图谱一个主语的所有谓语和宾语</li><li>相当于知识图谱的邻接表</li><li>只需单表就可以查询，不需要自连接</li></ul><h4 id="c.-属性表">c. 属性表</h4><ul><li>对水平表的细化，将同一类主语分配到一个表中</li></ul><h4 id="d.-垂直划分">d. 垂直划分</h4><ul><li>为知识图谱中的每个谓语建立一张两列的表（主语，宾语）</li></ul><h4 id="c.-六重索引">c. 六重索引</h4><ul><li>将三元组全部6中排列建立6张表（SPO、SOP、PSO、POS、OSP、OPS），缓解三元组表的自连接问题</li></ul><h4 id="d.-db2rdf">d. DB2RDF</h4><ul><li>将表的列作为谓语和宾语的存储位置，而不将列与谓语进行绑定</li><li>存储方案由 <strong>4 张表组成</strong>：dph 表、rph 表、ds 表和 rs 表<ul><li>dph（direct primary hash） 表为主表，一行存储一个主语，及其全部谓语和宾语<ul><li>当某个主语包含的谓语数目大于K时，剩余谓语溢出到下一行，spill 列为溢出标志（spill 列为1时，溢出）</li><li>dph 表实现了<strong>列的共享</strong>。不同实体的相同谓语总是会被分配到相同的列上，同一列中可以存储多个不同的谓语</li></ul></li><li>ds 表（direct secondary hash）处理多值谓语。当 dph 表中遇到多值谓语时，在相应宾语处生成一个唯一 id，将该 id 和每个对应的宾语存储为 ds 表的一行</li><li>rph 表（reverse primary hash）和 rs 表（reverse secondary hash）与dph 表和 ds 表（出边信息，从主语经谓语到宾语）相反，存储了实体节点的入边信息（从宾语经谓语到主语），以提高查询处理效率</li></ul></li><li>DB2RDF 中关键是处理<strong>谓语到列的映射</strong>。涉及到两个优化目标：列的数目不要超过某个值 m；尽量减少将同一个主语的不同谓语分配到同一列的情况，从而减少溢出现象<ul><li>一种方法是使用<strong>散列函数</strong><ul><li>使用一组散列函数，将谓语映射到一组列编号，并将谓语及其宾语存储到这组列中的第一个空列上</li><li>在一个主语对应的一行中，当谓语经过优先级较高的散列函数计算得出的列被占据时，则存储至下一低优先级的散列函数算得出的列上；当所有散列函数计算得出的列均被占据时，则溢出，同时溢出时所占据的列仍由该组散列函数决定</li></ul></li><li>若可以事先获取知识图谱的一个子集，则可以利用知识图谱的内在结构优化谓语到列的映射，将映射问题转化为<strong>图着色（Graph Coloring）问题</strong><ul><li>将一个主语上出现的不同谓语称为共现谓语（Co-occurrence Predicates），目标是让共现谓语着上不同颜色（映射到不同列），非共现谓语上可以上相同颜色</li><li>构建图着色算法的冲突图：图中节点为知识图谱中的所有谓语，每对共现谓语节点由一条边连接</li><li>图着色是经典的 NP 难问题，对于规模较大的冲突图，可用贪心算法（如 Welsh-Powell算法）求得近似解</li><li>若图着色所需颜色数量超过列数上限 <span class="math inline">\(m\)</span>，则根据某种策略（如最频繁使用的前k个谓语）选取一个谓语子集，使该谓语子集满足图着色要求；对于不在该子集的谓语，使用散列函数组策略进行映射</li></ul></li></ul></li></ul><h3 id="面向-rdf-的三元组数据库">3.3.2 面向 RDF 的三元组数据库</h3><h4 id="a.-jena开源">a. Jena（开源）</h4><ul><li>Apache 的顶级项目，从发布起一直是语义 Web 领域最为流行的开源 Java 框架和 RDF 数据库之一，并始终遵循 W3C 标准</li><li>功能：RDF 数据管理、RDFS 和 OWL 本体管理、SPARQL 查询处理</li><li>支持的三元组格式包括：RDF/XML、Turtle、N-Triples 和 RDFa</li><li>维护了一张大的三元组表和三种属性表<ul><li>单值属性表</li><li>多值属性表</li><li>属性类表</li></ul></li><li>提供了一个名为 Fuseki 的独立 RDF 数据库 Web 应用程序，基于 Jena 的 SPARQL 服务器</li></ul><h4 id="b.-rdf4j开源">b. RDF4J（开源）</h4><ul><li><p>支持所有主流的RDF数据格式，包括RDF/XML、Turtle、N-Triples、N-Quads、JSON-LD、TriG、TriX</p></li><li><p><strong>模块化的软件架构设计</strong>，使其成为很多其他 RDF 三元组数据库（如 GraphDB）的上层标准框架，这些三元组库只需要实现各自的 SAIL API，实现不同三元组库之间的透明切换</p></li></ul><h4 id="c.-rdf-3x开源">c. RDF-3X（开源）</h4><ul><li>其为 RDF 数据精心打造了压缩物理存储方案、查询处理和查询优化技术</li><li>在物理存储上，使用<strong>基于 B+ 树的压缩方案</strong></li><li>只支持 Linux，且是命令行程序</li></ul><h4 id="d.-gstore开源">d. gStore（开源）</h4><ul><li>为了加速查找，使用 <strong>“VS 树”索引</strong></li><li>只支持 Linux，且是命令行程序，提供了 HTTP 接口</li></ul><h4 id="e.-virtuoso商业">e. Virtuoso（商业）</h4><ul><li>可以支持多种数据模型的混合数据库管理系统</li><li>同时发布了商业版 Virtuoso Universal Server 和开源版 OpenLink Virtuoso</li><li>较为完善地支持W3C的Linked Data协议，包括 <strong>DBpedia</strong> 在内的很多开放 RDF 知识图谱选择其作为后台存储系统</li></ul><h4 id="f.-allegrograph商业">f. AllegroGraph（商业）</h4><ul><li>对语义推理功能具有较完善的支持</li><li>支持 Java、Python、C#、Ruby、Clojure/Scala、Lisp 等多种语言的编程访问接口</li><li>免费版存储的 RDF 三元组数量不能超过 500 万条</li><li>操作系统为 64 位 Linux</li></ul><h4 id="g.-graphdb商业">g. GraphDB（商业）</h4><ul><li>可以使用 RDF4J 的 RDF 模型、解析器和查询引擎直接访问 GraphDB</li><li>企业版支持多台机器的集群分布式部署</li></ul><h4 id="h.-blazegraph商业">h. Blazegraph（商业）</h4><ul><li>在用户接口层<strong>同时支持RDF三元组和属性图模型</strong></li><li>内部实现仍是面向 RDF 三元组和 SPARQL</li><li>支持<strong>真正意义上的集群分布式存储和查询处理</strong></li><li>被 <strong>wikidata</strong> 选为查询服务的后台图数据库系统</li></ul><h4 id="i.-stardog商业">i. Stardog（商业）</h4><ul><li>支持RDF图数据模型、SPARQL查询语言、属性图模型、Gremlin图遍历语言等，</li><li>支持OWL2推理机制</li><li>具备全文搜索、GraphQL 查询、路径查询、融合机器学习任务等功能</li></ul><h3 id="原生图数据库">3.3.3 原生图数据库</h3><ul><li>原生图数据库。目前大部分图数据库还不能直接支持 RDF 三元组存储</li></ul><h4 id="a.-neo4j">a. Neo4j</h4><ul><li>其是目前流行度最高的图数据库产品，不足之处在于其社区版是单机系统</li><li>虽然其<strong>企业版支持高可用性集群</strong>，但是其与分布式图存储系统的最大区别在于每个节点上存储图数据库的完整副本</li><li>为属性图结构中的节点、节点属性、边、边属性等设计了专门的存储方案</li></ul><h4 id="b.-janusgraph">b. JanusGraph</h4><ul><li>以Titan系统为基础，全面支持 Blueprints 标准和 Gremlin 语言</li><li><p>支持多用户并发访问和实时图遍历查询</p></li><li><p>目前还不支持真正意义上的分布式查询处理，如子图匹配查询、正则路径查询等</p></li><li><p>支持 Hadoop MapReduce 的图分析引擎，可以将 Gremlin 导航查询转化为 MapReduce 任务</p></li></ul><h4 id="c.-orientdb">c. OrientDB</h4><ul><li>支持扩展的 SQL 和 Gremlin，同时在 2.2 版本引入 MATCH 语句，实现了声明式的模式匹配</li><li>对数据模式的支持相对灵活，可以管理无模式（Schema-less）数据、完整模式数据、混合模式数据。支持图、文档、键值、对象、关系等多种数据模型，但底层主要面向图和文档数据存储管理的需求设计</li><li>功能相对全面：支持完整事物处理 ACID 特性、基于多主机赋值模式的分布式部署、多操作系统支持</li></ul><h4 id="d.-cayley">d. Cayley</h4><ul><li>支持多种查询语言，包括基于 Gremlin 的 Gizmo、GraphQL 和 MQL</li><li>支持多种存储后端，包括键值数据库 Bolt、LevelDB；NoSQL 数据库 MongoDB、CouchDB、PouchDB、ElasticSearch；关系数据库 PostgreSQL、MySQL 等</li><li>具有良好的模块化设计</li><li>可以存储 N-Quads 格式的 RDF 文件，但<strong>尚不支持 SPARQL 查询</strong></li></ul><h3 id="原生图数据库存储方案">3.3.4 原生图数据库存储方案</h3><ul><li>一般认为具有<strong>“无索引邻接”特性（Index-Free Adjacency）</strong>的图数据库才成为原生图数据库<ul><li>实现了“无索引邻接”的图数据库，每个节点维护着指向其邻接节点的直接引用，相当于每个节点都可以看做是其邻接节点的一个<strong>“局部索引”</strong>，这比“全局索引”更节省时间。</li><li>同时意味着图导航操作代价与图大小无关，仅与图遍历范围成正比</li><li>只有将图数据库的边表示的关系当做数据库的“一等公民”（即数据库中最基本、最核心的概念），才能实现真正的“无索引邻接”特性</li></ul></li></ul><h4 id="neo4j的存储方案-page-122">Neo4j的存储方案 <code>~Page 122~</code></h4><ul><li>属性图的不同部分是分开存储在不同文件中的。其中具有<strong>定长记录</strong>的图结构与具有变长记录的属性数据分开存储。已知记录 id 可以 <span class="math inline">\(O(1)\)</span> 的代价直接计算其存储地址<ul><li>节点记录文件。</li><li>边记录文件。两个双向链表，起始节点上的边和终止节点上的边</li><li>属性记录文件。单向链表</li></ul></li></ul><h3 id="原生图数据库的索引">3.3.5 原生图数据库的索引</h3><ul><li>索引分为两类：<ul><li>对节点和边上属性数据的索引（B+ 树索引技术）</li><li>对图结构的索引（业界没有达成共识的开放问题）</li></ul></li></ul><h4 id="neo4j-的属性数据索引">Neo4j 的属性数据索引</h4><ul><li>目前支持用户对同一类型节点的某个属性数据建立索引，以加速对某属性的查询处理性能</li><li>在查询时，不需要指定需要使用的索引，查询优化器会自动选择要用到的索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构建索引</span><br><span class="line">CREATE INDEX ON :程序员(姓名)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除索引</span><br><span class="line">DROP INDEX ON :程序员(姓名)</span><br></pre></td></tr></table></figure><h4 id="图结构索引">图结构索引</h4><ul><li>分为“基于路径的”和“基于子图的”两种<ul><li><strong>基于路径的图索引</strong><ul><li>GraphGrep</li><li>将图中长度小于或等于一个固定长度的全部路径构建为索引结构</li><li>索引的关键字可以是组成路径的节点或边上属性值或标签的序列</li></ul></li><li><strong>基于子图的索引</strong><ul><li>可以看做是基于路径索引的一般化形式</li><li>将图数据中的某些子图结构信息作为关键字，将子图的实例数据作为值</li><li>一个图数据的子图有指数个，将哪些子图作为关键词建立索引还没有很好地解决<ul><li>在图数据中发现出现次数多的频繁子图</li><li>从用户查询日志中挖掘频繁使用的子图模式</li></ul></li></ul></li></ul></li></ul><hr><h1 id="知识抽取">4. <a id="4">知识抽取</a></h1><h2 id="面向非结构化数据的知识抽取">4.1 面向非结构化数据的知识抽取</h2><ul><li>命名实体识别</li><li>关系抽取</li><li>事件抽取</li></ul><h2 id="面向结构化数据的知识抽取-page-154">4.2 面向结构化数据的知识抽取 <code>~Page 154~</code></h2><ul><li>W3C 的 RDB2RDF 工作组于2012年发布了两个推荐的 <strong>RDB2RDF 映射语言</strong>：DM（Direct Mapping，直接映射） 和 R2RML<ul><li>主要用于定义关系数据库中的数据如何转换为 RDF 数据的各种规则，包括 URI 的生成、RDF 类和属性的定义、空节点的处理、数据间关联关系的表达等</li></ul></li><li>从结构化数据库中获取知识（转化为RDF数据、OWL本体等）一般使用现有的<strong>D2R工具</strong>，如 D2RQ（D2RServer，HTTP Server）、DB2triples、Triplify、OpenLink、SparqlMap、Ontop等 <code>~Page 159 Page 426~</code></li></ul><div class="figure"><img src="/2020/06/25/knowledge-graph-book/D2R工具.png" alt="D2R工具"><p class="caption">D2R工具</p></div><h3 id="直接映射">4.2.1 直接映射</h3><ul><li><strong>基本规则</strong>：<ul><li>数据库中的表映射为 RDF 类</li><li>列映射为 RDF 属性</li><li>行映射为一个资源或实体，创建 IRI（Internationalized Resource Identifiers 国际化资源标识符，引入 Unicode 字符的 URI）</li><li>每个单元格的值映射为一个文字值（Literal Value）；若单元格的值对应一个外键，则将其替换为外键值指向的资源或实体的 IRI</li></ul></li><li>直接映射不会为 NULL 值生成三元组</li></ul><h3 id="r2rml">4.2.2 R2RML</h3><ul><li>输入是符合用户定义的数据库模式的关系数据库，输出是采用目标词汇表中谓词和类型描述的 RDF 数据集</li><li>R2RML 输出 <strong>Turtle</strong> 语法的 RDF 数据</li><li>通过<strong>逻辑表（Logic Tables）</strong>从数据库中检索数据，一个逻辑表可以是数据库中的一个表、视图或有效的 SQL 语句查询</li><li>每个逻辑表通过<strong>三元组映射（Triples Map）</strong> 映射至 RDF 数据，三元组映射可以将逻辑表中每一行映射为若干 RDF 三元组规则<ul><li>三元组映射规则主要包括两个部分：<strong>一个主语映射和多个谓语 - 宾语映射</strong><ul><li>主语映射从逻辑表生成所有 RDF 三元组的主语</li><li>谓语 - 宾语映射包含了谓语和宾语映射</li></ul></li></ul></li><li>需要定义<strong>映射文档</strong> <code>~Page 157~</code></li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">@prefix rr: &lt;http:<span class="comment">//www.w3.org/ns/r2rml#&gt; .</span></span><br><span class="line">@prefix <span class="keyword">ex</span>: &lt;http:<span class="comment">//example.com/ns#&gt; .</span></span><br><span class="line"></span><br><span class="line">&lt;#TriplesMap1&gt;</span><br><span class="line"><span class="comment">// 逻辑表</span></span><br><span class="line">rr:logicalTable [rr:tableName <span class="string">"EMP"</span>];</span><br><span class="line"><span class="comment">// 主语映射，EMPNO 为数据库中 EMP 表的 EMPNO 列</span></span><br><span class="line">rr:subjectMap [</span><br><span class="line">rr:template <span class="string">"http://data.example.com/employee/&#123;EMPNO&#125;"</span> ;</span><br><span class="line">rr:<span class="keyword">class</span> <span class="keyword">ex</span>:Employee;</span><br><span class="line">];</span><br><span class="line"><span class="comment">// 谓语-宾语映射，设定 ENAME 列的谓语，宾语为文字值</span></span><br><span class="line">rr:predicateObjectMap [</span><br><span class="line">rr:predicate <span class="keyword">ex</span>:name;</span><br><span class="line">rr:objectMap [ rr:column <span class="string">"ENAME"</span> ];</span><br><span class="line">].</span><br><span class="line"><span class="comment">// 将 EMP 和 DEPT 表连接，实现三元组的主语和宾语均为实体，</span></span><br><span class="line"><span class="comment">// parentTriplesMap只能有一个，代表参考宾语映射（referencing object map）的父三元组映射（parent triples map）</span></span><br><span class="line"><span class="comment">// rr:child 必须在包含参考宾语映射的当前三元组映射的逻辑表的列上</span></span><br><span class="line"><span class="comment">// rr:parent 必须在参考宾语映射的父三元组映射的逻辑表的列上</span></span><br><span class="line"><span class="comment">// 设&lt;#TriplesMap2&gt;的逻辑表是DEPT，则下述代表EMP.DEPTNO = DEPT.DEPTNO</span></span><br><span class="line">rr:predicateObjectMap [</span><br><span class="line">rr:predicate <span class="keyword">ex</span>:department;</span><br><span class="line">rr:objectMap [ </span><br><span class="line">rr:parentTriplesMap &lt;#TriplesMap2&gt;;</span><br><span class="line">rr:jointCondition [</span><br><span class="line">rr:child <span class="string">"DEPTNO"</span>;</span><br><span class="line">rr:parent <span class="string">"DEPTNO"</span>;</span><br><span class="line">];</span><br><span class="line">];</span><br><span class="line">].</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于 SQL 语句定义查询视图</span></span><br><span class="line">&lt;#DeptTableView&gt; rr:sqlQuery <span class="string">""</span>"</span><br><span class="line">SELECT DEPTNO, DNAME, <span class="keyword">LOC</span>, </span><br><span class="line">   (SELECT <span class="keyword">COUNT</span>(*) FROM EMP WHERE EMP.DEPTO=DEPT.DEPTNO) <span class="keyword">AS</span> STAFF</span><br><span class="line">FROM DEPT;</span><br><span class="line"><span class="string">""</span>".</span><br><span class="line"></span><br><span class="line">&lt;#TriplesMap2&gt;</span><br><span class="line"><span class="comment">// 逻辑表</span></span><br><span class="line">rr:logicalTable &lt;#DeptTableView&gt;;</span><br><span class="line">rr:subjectMap [</span><br><span class="line">rr:template <span class="string">"http://data.example.com/department/&#123;DEPTNO&#125;"</span> ;</span><br><span class="line">rr:<span class="keyword">class</span> <span class="keyword">ex</span>:Department;</span><br><span class="line">];</span><br><span class="line">rr:predicateObjectMap [</span><br><span class="line">rr:predicate <span class="keyword">ex</span>:name;</span><br><span class="line">rr:objectMap [ rr:column <span class="string">"DNAME"</span> ];</span><br><span class="line">].</span><br><span class="line">rr:predicateObjectMap [</span><br><span class="line">rr:predicate <span class="keyword">ex</span>:location;</span><br><span class="line">rr:objectMap [ rr:column <span class="string">"LOC"</span> ];</span><br><span class="line">].</span><br><span class="line">rr:predicateObjectMap [</span><br><span class="line">rr:predicate <span class="keyword">ex</span>:staff;</span><br><span class="line">rr:objectMap [ rr:column <span class="string">"STAFF"</span> ];</span><br><span class="line">].</span><br></pre></td></tr></table></figure><h3 id="基于本体的数据库访问obtology-based-database-access系统">4.2.3 基于本体的数据库访问（Obtology Based Database Access）系统</h3><ul><li><p>支持以访问知识图谱的形式直接访问关系数据库，可以使用 SPARQL 查询数据库信息</p></li><li><p>D2RQ、Mastro、Ultrawrap、Morph-RDB、Ontop <code>~Page 159~</code></p></li></ul><h2 id="面向半结构化数据的知识抽取-page-161">4.3 面向半结构化数据的知识抽取 <code>~Page 161~</code></h2><ul><li>不符合关系数据库或其他数据表形式的结构，但又包含标签或其他标记来分离语义元素并保持记录和数据字段的层次结构</li></ul><h3 id="面向百科类数据的知识抽取">4.3.1 面向百科类数据的知识抽取</h3><ul><li><p><strong>维基百科</strong>（DBpedia、Yago）已经成为构建大规模知识图谱的重要数据来源，中文有百度百科、互动百科（Zhishi.me、XLore、CN-DBpedia）</p></li><li>词条页面结构包含了词条标题、词条摘要、跨语言链接、分类、信息框等要素</li><li><strong>DBpedia</strong><ul><li>目前最大的跨领域知识图谱之一，458万实体（2019.02），30亿条 RDF 三元组，其中5.8亿从维基百科英文版中提取</li><li>总体架构中最关键的是抽取器和解析器<ul><li>抽取器用于将特定类型的维基标记转换为三元组</li><li>解析器用于确定数据类型，在不同单元之间转换值并将标记分解成列表</li></ul></li></ul></li></ul><h3 id="面向-web-网页的知识抽取">4.3.2 面向 Web 网页的知识抽取</h3><ul><li>从网页获取结构化信息一般通过<strong>包装器</strong>实现</li><li>包装器的<strong>生成方法</strong>有三类：手工方法、包装器归纳方法和自动抽取方法<ul><li>手工编写适合当前网站的抽取表达式，可以是 XPath 表达式、CSS选择器的表达式等</li><li>包装器归纳方法是基于有监督学习的方法，从已标注的训练样例集合中学习信息抽取的规则</li><li>自动抽取方法中，相似的网页首先通过聚类被分为若干组，通过挖掘同一组中相似网页的重复模式，可以生成适用于该组网页的包装器</li></ul></li></ul><h2 id="知识抽取工具">4.4 知识抽取工具</h2><ul><li><strong>Stanford NLP</strong> 开源文本预处理工具</li><li><strong>DeepDive</strong> 开源关系抽取工具</li><li>Reverb 三元组抽取工具</li><li>OLLIE 三元组抽取工具，支持基于语法依赖书的关系抽取</li><li>Wandora 封装好的知识抽取桌面程序</li><li><strong>文本抽取可以分为 OpenIE 和 CloseIE 两种</strong> <code>~Page 426~</code><ul><li>OpenIE 面向开放领域，是一种基于语言学模式的抽取，通常抽取规模大、精度较低<ul><li>Reverb</li><li>TextRunner</li></ul></li><li>CloseIE 面向特定领域，基于领域专业知识抽取，通常抽取规模小、精度较高<ul><li>DeepDive</li></ul></li></ul></li></ul><hr><h1 id="知识挖掘">5. 知识挖掘</h1><ul><li>从已有的实体及关系出发挖掘新的知识，包括知识内容挖掘和知识结构挖掘</li></ul><h2 id="知识内容挖掘实体链接">5.1 知识内容挖掘：实体链接</h2><ul><li>通过实体链接，文本中的实体指称与其在知识库中对应的实体建立的链接</li><li>其<strong>基本流程</strong>包括：实体指称识别、候选实体生成和候选实体消岐<ul><li>实体指称识别可以通过命名实体识别技术或词典匹配技术实现</li><li>候选实体生成的方法<ul><li>表层名字扩展。从实体提及出现的相关文档中识别其他可能的扩展变体</li><li>基于搜索引擎的方法。将实体提及和上下文提交至搜索引擎，根据返回检索结果生成候选实体</li><li>构建查询实体引用表。建立实体提及与候选实体的对应关系</li></ul></li><li>候选实体消岐的方法<ul><li>基于图的方法。将实体指称、实体以及它们之间的关系通过图的形式表示出来</li><li>基于概率生成模型的方法。对实体提及和实体的联合概率进行建模</li><li>基于主题模型的方法。在同一个文本中出现的实体应该与文本表述的主题相关，对实体在文本中的相容度、实体与话题的一致性进行联合建模</li><li>基于深度学习的方法</li></ul></li></ul></li></ul><h2 id="知识结构挖掘规则挖掘">5.2 知识结构挖掘：规则挖掘</h2><ul><li>OWL DL 基于描述语言，无法描述 <code>if ... then ...</code> 形式的规则</li><li>SWRL 基于霍恩语句，可以有效描述 <code>if ... then ...</code> 形式的规则</li></ul><h3 id="归纳逻辑程序设计inductive-logic-programmingilp">5.2.1 归纳逻辑程序设计（Inductive Logic Programming，ILP）</h3><ul><li>以一阶逻辑归纳为理论基础，，并以一阶逻辑为表达语言的符号规则学习算法</li><li>ILP 系统可以学习获得<strong>描述目标谓词的逻辑规则集合</strong></li><li>FOLI 是早期有代表性的 ILP 系统<ul><li>设定目标谓词和背景知识，同时目标谓词有正例和反例</li><li>在规则学习中，从空规则（如 <span class="math inline">\(daughter(X,Y)\leftarrow\)</span>）开始</li><li>而后逐一将可用谓词加入规则体（如<span class="math inline">\(daughter(X,Y)\leftarrow female(X)\)</span>，$daughter(X,Y)<span class="math inline">\($female(X), parent(Y,X)\)</span>）进行考察，按照预定标注评估规则优劣并选取最优规则</li><li>持续谓词的添加直至规则只覆盖正例，而不覆盖任何反例</li></ul></li><li>多数 ILP 系统仅适用于小规模数据集，在较大规模数据集上运行效率不高</li><li><strong>AMIE 和 AMIE+ 系统</strong> 针对大规模知识图谱特点，定义了新的支持度和覆盖度度量对搜索空间进行剪枝，并可在知识图谱不完备条件下评价规则</li></ul><h3 id="路径排序算法path-ranking-algorithmpra">5.2.2 路径排序算法（Path Ranking Algorithm，PRA）</h3><ul><li>将关系路径作为特征的知识图谱链接预测算法</li><li>基本思想是通过发现连接两个实体的一组关系路径来预测实体间可能存在的某种特定关系</li><li>三个步骤：<ul><li>特征选择。仅保留对预测目标关系潜在有用的关系路径。使用基于随机游走的特征选择方法，对于某个关系路径，基于随机游走计算该路径的准确度和覆盖度<ul><li>准确度描述沿某个关系路径，可以抵达目标实体的概率</li><li>覆盖度描述沿某个关系路径，可以覆盖目标实体的数量</li></ul></li><li>特征计算。计算不同关系路径抵达目标实体的概率</li><li>特征分类。预测知识图谱中任意两个实体间是否存在某特定关系</li></ul></li></ul><hr><h1 id="知识图谱融合">6. <a id="6">知识图谱融合</a></h1><ul><li><strong>该书本章节的内容写的不好，比较乱，没有条理</strong></li><li>知识图谱包含描述抽象知识的本体层和描述具体事实的实例层</li><li><strong>本体异构</strong>：本体描述内容在语义上存在重叠或关联，但本体在表示语言和表示模型上却具有差异</li><li><strong>实例异构</strong>：同名实例可能指代不同实体，不同名实例可能指代同一实体</li></ul><h2 id="知识图谱中的异构问题">6.1 知识图谱中的异构问题</h2><h3 id="语言层不匹配">6.1.1 语言层不匹配</h3><ul><li>指用来描述知识的元语言不匹配</li><li>当不同时期构建的知识（早期 Ontolingua、Loom等）或同一时期采用不同语言表示的知识（近年 DAML+OIL、RDF(S)、OWL 和 OWL2 等）进行交互时，首先面临由于<strong>知识表示语言之间的不匹配</strong>所造成的异构问题</li></ul><h4 id="a.-语法不匹配">a. 语法不匹配</h4><ul><li>近年的本体语言基本采用 XML 的书写格式，而早期的本体语言则没有固定的格式</li></ul><h4 id="b.-逻辑表示不匹配">b. 逻辑表示不匹配</h4><ul><li>比如表示两个类不相交</li></ul><h4 id="c.-原语的语义不匹配">c. 原语的语义不匹配</h4><ul><li>比如 OWL Lite 和 OWL DL 语言中，原语 “Class” 声明的对象只能作为本体中的概念，而在 OWL Full 和 RDF(S) 中，可以作为一个类，也可以作为一个实例</li></ul><h4 id="d.-语言表达能力不匹配">d. 语言表达能力不匹配</h4><ul><li>不同本体语言表达能力上的差异</li></ul><h3 id="模型层不匹配">6.1.2 模型层不匹配</h3><ul><li>由于本体建模方式不同所造成的不匹配，以及对本体成分解释的不匹配</li></ul><h4 id="a.-概念化不匹配">a. 概念化不匹配</h4><ul><li><p>由于对同样建模领域进行抽象的方式不同造成的</p></li><li>可以分为<strong>概念范围的不匹配和模型覆盖的不匹配</strong><ul><li>概念范围的不匹配<ul><li>同样名称的概念在不同领域内表示的含义有差异；同时不同建模者出于对领域需求或主观认识上的不同，在建模过程中对概念的划分上往往也有差异</li></ul></li><li>模型覆盖的不匹配<ul><li>不同本体对于描述的领域往往在覆盖的知识范围上有差异；同时对于所覆盖的范围，它们之间描述的详细程度也有差异</li><li>包含<strong>三个维度</strong>：模型的广度（本体模型描述的领域范围）、模型的粒度（描述的详细程度）、本体建模的观点（从什么认识角度描述领域内知识）</li></ul></li></ul></li></ul><h4 id="b.-解释不匹配">b. 解释不匹配</h4><ul><li>由于对概念化说明的方式不同造成的</li><li>可以分为<strong>模型风格的不匹配和建模术语上的不匹配</strong><ul><li>模型风格的不匹配<ul><li>范例不匹配。例如对时间的表示可以采用基于时间间隔的方式，也可以使用基于时间点的方式</li><li>概念描述不匹配。对同一个概念的建模有多种选择</li></ul></li><li>建模术语的不匹配<ul><li>同义术语。不同本体含义相同的概念，使用不同的名字表示</li><li>同形异义术语。</li><li>编码格式。相同类型的数据编码格式不同，比如距离可以用 mile 描述，也可以用 kilometer 描述</li></ul></li></ul></li></ul><h2 id="本体概念层的融合方法与技术">6.2 本体概念层的融合方法与技术</h2><ul><li>解决本体异构的通用方法时本体集成与本体映射</li></ul><h3 id="本体集成">6.2.1 本体集成</h3><ul><li><strong>本体集成</strong>直接将多个本体合并为一个大本体</li><li>本体集成分为单本体集成和全局本体 - 局部本体集成<ul><li>单本体集成。直接将多个异构本体集成为一个统一的本体<ul><li><strong>流程</strong>为：决定本体集成的方式（从头构建还是利用现有本体集成）、识别本体的模块、识别每个模块中应被表示的知识、识别候选本体、执行集成过程</li></ul></li><li>全局本体 - 局部本体集成<ul><li>首先抽取异构本体之间的公共知识，建立一个全局本体；同时各个系统可以拥有自己的本体，称为局部本体</li><li>需要建立局部本体与全局本体之间的映射</li></ul></li></ul></li></ul><h3 id="本体映射">6.2.2 本体映射</h3><ul><li><strong>本体映射</strong>寻找本体之间的映射规则</li><li>本体映射和集成虽然存在差异，但相互之间也存在联系。很多时候，<strong>映射可以看做是集成的子过程</strong></li><li>本体映射通过建立本体之间的映射规则，达到<strong>本体互操作</strong>，形式比较灵活，更能适应分布动态的环境</li><li><strong>本体映射并不直接以各种不匹配准则来划分</strong></li><li>本体映射的<strong>分类</strong><ul><li>映射对象的角度<ul><li>明确映射应该建立在异构本体的哪些成分，本体映射建立在由概念、关系、实例和公理组成的基本成分之上（通常不考虑实例和公理）</li></ul></li><li>映射功能的角度<ul><li>明确应该建立具有何种功能的本体映射</li><li><strong>11种主要的本体映射（异构本体间的桥）</strong><code>~Page 194~</code></li><li>有的映射仅仅为了建立本体之间的数据转换规则，有的映射还能用于进行跨本体的推理和查询应用</li></ul></li><li>映射的复杂程度角度<ul><li>明确什么形式的映射是简单的，什么形式的映射是复杂的</li><li>通常将那些基本的、必要的、组成简单和发现过程相对容易的映射称为简单映射；将不直观、组成复杂并且发现过程相对困难的映射称为复杂映射</li></ul></li></ul></li></ul><h3 id="发现本体映射的方法">6.2.3 发现本体映射的方法</h3><h4 id="a.-基于术语和结构的本体映射">a. 基于术语和结构的本体映射</h4><ul><li>基于术语的本体映射。从本体术语出发，比较与本体成分相关的名称、标签或注释，寻找异构本体间的相似性<ul><li>基于字符串的方法。<strong>汉明距离、子串相似度、编辑距离、路径距离</strong></li><li>基于语言的方法。依靠自然语言处理技术寻找概念或关系之间的联系（内部方法：语言内部属性，如形态和语法特点；外部方法：外部资源，如词典）</li></ul></li><li>基于结构的本体映射。<ul><li>内部结构。利用如属性关系的定义域、基数、传递性或对称性</li><li>外部结构。依据概念邻居的相似度。<strong>判断本体成分相似性准则</strong> <code>~Page 199~</code><ul><li>外部结构的方法无法解决由于本体建模的观点不同而造成的异构</li></ul></li></ul></li><li><strong>方法和工具</strong> <code>~Page 200~</code><ul><li><strong>AnchorPROMPT</strong>。属于 PROMPT 中的一个工具，已经集成在 Protege 中</li><li>iPROMPT。属于 PROMPT 中的一个工具，已经集成在 Protege 中</li><li>MAFRA。处理语义 Web 上分布式本体间映射的一个框架</li><li>ONION。寻找原子之间的等价关系</li><li><strong>Wang Peng 和 Xu Baowen 的方法</strong>。使用概念的同义词集相似度、概念特征上的相似度、概念上下文上的相似度评估本体间概念的相似度。评估概念等价和上义下义的继承关系</li><li><strong>S-Match</strong>。可以评估的语义关系有：等价、泛化、特化、不匹配和相交。与一些基于术语和结构的本体映射系统比较，其在查准率和查全率方面都比较好，但是执行时间长</li><li>Cupid。与其他混合方法比较，其得到更好的映射结果。只支持简单映射</li><li>Chimaera。可以识别术语间是否包含或不相关等简单映射关系</li><li>BUSTER。建立局部本体和基本词汇集之间的映射</li><li>COMA。匹配器大多基于字符串技术，支持在匹配过程中与用户进行交互</li><li>ASCO。</li></ul></li><li><strong>Notes</strong><ul><li><strong>同一本体中，父概念与子概念的相似度，通常小于子概念与父概念的相似度 <code>~Page 209~</code></strong></li><li>总的来说，基于术语和结构的本体映射取得的映射结果都不让人满意，<strong>大多数工作只能发现简单概念之间的等价和包含映射，以及原子关系之间的等价</strong></li></ul></li></ul><h4 id="b.-基于实例的本体映射">b. 基于实例的本体映射</h4><ul><li>比较概念的外延，即本体的实例，发现异构本体的语义关联。分为两种情况：本体概念间存在共享实例和没有存在共享实例<ul><li>共享实例的方法。<ul><li>最简单的方法是测试实例集合的交集。当 <span class="math inline">\(A\cap B=A=B\)</span> 时，两概念等价</li><li><strong>对称差分</strong>。<span class="math inline">\(\delta(s, t)=|s\cup t-s\cap t|/|s\cup t|\)</span> ，其值越大，代表概念间的差异越大</li></ul></li><li>无共享实例的方法<ul><li>根据连接聚合等数据分析方法获得实例集之间的关系</li></ul></li></ul></li><li>方法和工具 <code>~Page 213</code><ul><li><strong>GLUE</strong>。<ul><li>早期经典的本体映射工作之一</li><li>应用机器学习技术，采用半自动方式发现异构本体的映射</li><li>被扩展为 CGLUE 系统，以寻找复杂的映射，实现 1：n 的映射</li><li>无法处理异构本体的关系之间的映射</li></ul></li><li>概念近似方法<ul><li>解决异构本体的近似查询，提供了一类表示和发现概念间映射的方法</li><li>通过获取概念的上近似和下近似，来重写查询表达式，以获得较高的查全率的查准率</li></ul></li><li><strong>FCA</strong><ul><li>基于不同本体间的共享实例，解决本体映射的发现问题</li><li>使用形式化概念分析技术</li><li>处理 1:1 的简单映射类型</li></ul></li><li>IF-Map<ul><li>基于信息流理论</li><li>通过查看他们与一个通用的参考本体的映射，来寻找两个局部本体间的等价</li><li>核心在于生成参考本体和局部本体之间的可能映射，然后根据这些映射判断两局部本体之间的等价关系</li><li>只能生成异构本体概念间的简单等价映射</li></ul></li></ul></li><li><strong>Notes</strong><ul><li>集合的<strong>合取</strong>，代表集合的交集；集合的<strong>析取</strong>，代表集合的并集 <code>~Page 222~</code></li><li>相比于基于术语和结构的映射方法，基于实例的本体映射更好，在映射的质量、类型和映射的复杂程度方面都取得不错的结果，但<strong>缺乏有效如何地建立共享实例集的方法</strong></li></ul></li></ul><h4 id="c.-综合方法">c. 综合方法</h4><ul><li>多种映射方法综合使用</li><li>方法和工具<ul><li><strong>QOM</strong>。<ul><li>同时考虑映射结果的质量与发现映射的时间复杂度，合理组织各种映射发现算法，力图寻找两者的平衡</li><li>可以处理大规模本体间的映射发现问题</li><li>只考虑异构本体间 1:1 等价映射，映射对象包括概念、关系和实例</li></ul></li><li>OLA<ul><li>覆盖本体所有可能的特征：术语、结构、外延</li><li>可以发现本体间的等价映射</li></ul></li><li>KRAFT<ul><li>可以发现 1:1 的本体映射，映射对象包括概念、属性、关系</li></ul></li><li>OntoMap<ul><li>不能自动创建映射</li></ul></li><li>OBSERVER<ul><li>为了解决分布式数据库的异构问题</li><li>能表示 1:1 映射，包括同义、上义、下义、重叠、不交和覆盖等</li><li>本体映射依靠手工建立</li></ul></li><li>InfoSleuth<ul><li>可以支持通过小本体组成复杂本体</li></ul></li><li>基于虚拟文档的本体匹配<ul><li>利用本体中的语义信息、文本信息和结构信息进行本体匹配</li><li>将本体中元素相关的文本组织为虚拟文档，然后用虚拟文档表示相应的元素</li></ul></li></ul></li></ul><h3 id="本体映射管理">6.2.4 本体映射管理</h3><ul><li>本体管理的任务有两方面<ul><li>设计本体库系统以增强本体管理，包括存储、搜索、编辑、一致性检查、检测、映射、以及不同形式间的转换等</li><li>本体版本或演化</li></ul></li><li>五层体系结构的多本体管理框架<ul><li>本体库层</li><li>本体表示层<ul><li>统一多个本体的表示形式</li></ul></li><li>描述本体间映射的桥本体层。<ul><li>桥本体是一种特殊的本体，可表示本体间概念和关系的 12 种不同映射</li></ul></li><li>多本体功能层<ul><li>实现异构本体的互操作、推理、信息检索、抽取子本体、提供更丰富的语义数据</li></ul></li><li>应用层</li></ul></li></ul><h3 id="本体映射的应用">6.2.4 本体映射的应用</h3><ul><li>子本体抽取</li><li>信息检索</li><li>辅助查询重写，提高对用户问题的语义理解能力</li></ul><h2 id="实例层的融合与匹配-page-236">6.3 实例层的融合与匹配 <code>~Page 236~</code></h2><ul><li>实例匹配通常是一个大规模数据处理问题，需要在匹配过程中解决其中的时间复杂度和空间复杂度问题，其难度和挑战更大<ul><li>空间复杂度挑战<ul><li>选择合理的数据结构，并利用一些数据压缩存储技术，现有计算机存储能力基本能满足多数大规模知识图谱匹配的需求</li></ul></li><li>时间复杂度挑战<ul><li>执行时间主要取决于匹配计算过程</li><li>减少匹配元素对的相似度计算次数，以及每次相似度计算的时间复杂度</li></ul></li><li>匹配结果质量挑战</li></ul></li><li><strong>现有的大规模知识图谱匹配方法分为三类</strong><ul><li>基于快速相似度计算的实例匹配方法</li><li>基于规则的方法</li><li>基于分治的方法</li></ul></li></ul><h3 id="基于快速相似度计算的实例匹配方法">6.3.1 基于快速相似度计算的实例匹配方法</h3><ul><li>尽量降低每次相似度计算的时间复杂度</li><li>映射过程只使用简单且速度较快的匹配器</li></ul><h3 id="基于规则的实例匹配方法">6.3.2 基于规则的实例匹配方法</h3><ul><li>基于 EM 算法的实例匹配框架</li><li>输入为待匹配三元组、初始匹配对阈值，输出为匹配结果集与 IFPS（逆功能属性集，一个等价的属性对集） 规则集</li></ul><h3 id="基于分治的实例匹配方法">6.3.3 基于分治的实例匹配方法</h3><ul><li>思想是降低相似度计算次数</li><li>将大规模知识图谱划分为 k 个小规模的知识图谱</li><li><strong>本体模块化方法</strong><ul><li>需保证局部正确性和完整性</li><li>划分模块数目少，模块规模不均匀</li><li>模块大小和边界信息损失是不可调和的，实际使用中需要权衡</li><li>模块化方法经过适当的优化，是可以处理大规模本体映射的（Malasco 系统）</li></ul></li><li>采用分治思想的典型系统：<ul><li>Malasco。多种优化方法</li><li>Falcon-AO。聚类方法</li><li>Lily。通过一些确定的匹配点，自动发现更多潜在匹配点，不需要划分知识图谱</li></ul></li></ul><h4 id="a.-基于属性规则的分块方法">a. 基于属性规则的分块方法</h4><ul><li>利用实例的属性值对其进行划分</li><li>减低分块结果冗余性的方法<ul><li>先把属性聚类，再分块</li><li>把冗余的判断看做为一个二分类问题，使用监督学习方法</li></ul></li></ul><h4 id="b.-基于索引的分块方法">b. 基于索引的分块方法</h4><ul><li>将<strong>实例信息分为以下六类</strong><ul><li>URI</li><li>元信息。实例的模式层信息</li><li>实例名。可以通过 RDFS:label 属性获取</li><li>描述性属性信息。实例的描述性语言，RDFS:comment</li><li>可区分属性信息。可以用于区分实例的属性</li><li>邻居信息。相邻实例</li></ul></li><li><strong>步骤</strong><ul><li>构建名称向量和虚拟文档</li><li>对名称向量中的每个词构建倒排索引</li><li>按照一定规则选择后续实例匹配集合，同时根据用户定义的属性对和值模式对待选匹配集优化</li><li>利用向量空间模型计算两个实例在向量空间的距离，如余弦相似度，进而获得名称向量相似度和虚拟文档向量相似度</li><li>对名称向量相似度和虚拟文档向量相似度加权求和，得到两个实例的最终相似度</li></ul></li></ul><h4 id="c.-基于聚类的分块方法">c. 基于聚类的分块方法</h4><ul><li>将一个本体中的概念聚类为多个小规模的簇</li><li>把具有关联关系的三元组还原到簇中<ul><li>如果三元组的主语和宾语都在一个簇中，则这个三元组在该簇中</li></ul></li></ul><h4 id="d.-基于局部性的分块方法">d. 基于局部性的分块方法</h4><ul><li>大规模知识图谱元素映射具有<strong>区域性特点</strong><ul><li>知识图谱 <span class="math inline">\(O_1\)</span> 的特定区域 <span class="math inline">\(D_i\)</span> 中的元素大多会被映射到知识图谱 <span class="math inline">\(O_2\)</span> 的特定区域 <span class="math inline">\(D_j\)</span> 中</li></ul></li><li>大规模知识图谱融合方法新思路<ul><li>由于<strong>匹配不能破坏原知识图谱的结构层次</strong>。当确定 <span class="math inline">\(O_1\)</span> 中的概念 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(O_2\)</span> 中的概念 <span class="math inline">\(B\)</span> 匹配时，则 <span class="math inline">\(A\)</span> 的子概念不必再与 <span class="math inline">\(B\)</span> 的父概念做匹配计算</li><li>由于匹配的元素集具有区域性。可认为元素及其邻居通常只与另一个本体中的部分元素相关，而与其他大多数元素无关。当能确定 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(B\)</span> 不匹配时，可认为 <span class="math inline">\(A\)</span> 的邻居与 <span class="math inline">\(B\)</span> 也不会匹配</li></ul></li><li><strong>正锚点</strong>： <span class="math inline">\(O_1\)</span> 中概念 <span class="math inline">\(a_i\)</span> 对应于 <span class="math inline">\(O_2\)</span> 中元素相似度大于某一阈值的概念集合为 <span class="math inline">\(a_i\)</span> 对应的正锚点<ul><li>如果相似度是对称的，则正锚点也是对称的</li><li>可以跳过 <span class="math inline">\(a_i\)</span> 的子概念与正锚点中对应概念 <span class="math inline">\(b_p\)</span> 的父概念的相似度计算，以及 <span class="math inline">\(a_i\)</span> 的父概念与正锚点中对应概念 <span class="math inline">\(b_p\)</span> 的子概念的相似度计算</li></ul></li><li><strong>负锚点</strong>： <span class="math inline">\(O_1\)</span> 中概念 <span class="math inline">\(a_i\)</span> 对应于 <span class="math inline">\(O_2\)</span> 中元素相似度小于某一阈值的概念集合为 <span class="math inline">\(a_i\)</span> 对应的负锚点<ul><li>如果相似度是对称的，则负锚点也是对称的</li><li>可以跳过 <span class="math inline">\(a_i\)</span> 的邻居与 <span class="math inline">\(b_n\)</span> 的相似度计算，以及 <span class="math inline">\(b_n\)</span> 的邻居与 <span class="math inline">\(a_i\)</span> 的相似度计算</li><li><strong><span class="math inline">\(a_i\)</span> 的邻居</strong>不限于直接邻居，而是包含在知识图谱中并与 <span class="math inline">\(a_i\)</span> 距离为 <span class="math inline">\(\texttt{nScale}\)</span> 内的元素</li></ul></li><li>正锚点包含一个概念或多个概念时的<strong>正约简集</strong>（根据正锚点预测得到的匹配位置）的计算 <code>~Page 254~</code></li><li>负锚点存在<strong>无限制传播</strong>的现象，导致<strong>负约简集</strong>（根据负锚点预测得到的匹配位置）的可信度的降低 <code>~Page 258~</code><ul><li>需要对负约简集的生成进行约束<ul><li>由邻居传播过来的负锚点不能被再次传播</li><li>负锚点能传播的邻居必须位于 <span class="math inline">\(a_i\)</span> 的语义子图内</li><li>当元素的语义描述文档包含词条数大于阈值 <span class="math inline">\(t\)</span> 时，产生的负锚点才能传播</li></ul></li></ul></li></ul><h3 id="基于学习的实例匹配方法">6.3.4 基于学习的实例匹配方法</h3><ul><li>将大规模知识图谱实例匹配视为机器学习的二分类问题</li></ul><h3 id="实体关系发现框架">6.3.5 实体关系发现框架</h3><ul><li>LIMES<ul><li>通过度量空间的三角不等式特征（度量空间的任意 3 个点 <span class="math inline">\(x,y,z\)</span> ，满足 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的距离与 <span class="math inline">\(y\)</span> 到 <span class="math inline">\(z\)</span> 的距离之和，大于 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(z\)</span> 的距离）来过滤大量不满足映射条件的实例对，从而减少比较次数<ul><li>如果空间 <span class="math inline">\(A\)</span> 中的 <span class="math inline">\(x,y\)</span> 的距离和样本点 <span class="math inline">\(y,z\)</span> 之间的距离的差值大于阈值，意味着 <span class="math inline">\(x,z\)</span> 之间的距离大于阈值，在计算过程中便不需要计算 <span class="math inline">\(x,z\)</span> 之间的距离</li></ul></li></ul></li><li>Dedupe<ul><li>基于主动学习的方法。用户需标注少量数据</li></ul></li><li>SILK</li><li>RIMOM</li><li>Falcon-AO</li><li>Lily</li></ul><hr><h1 id="知识图谱推理">7. <a id="7">知识图谱推理</a></h1><ul><li>推理的方法分为逻辑推理和非逻辑推理。此处主要针对逻辑推理（过程包含严格的约束和推理过程）</li><li>逻辑推理按推理方式的不同包含两大类<ul><li>演绎推理（deductive reasoning）<ul><li>演绎推理是一种自上而下的过程，是指在给定一个或多个前提下，推断出一个必然成立的结论</li><li>典型的演绎推理有：肯定前件假言推理、否定后件假言推理、假言三段论</li></ul></li><li>归纳推理（inductive reasoning）<ul><li>归纳推理是一种自下而上的推理，是指基于已有的部分观察得出一般结论的过程</li><li>包含了溯因推理（abductive reasoning）、类比推理（analogy reasoning）等</li><li>典型的归纳推理有：归纳泛化、统计推理</li></ul></li></ul></li><li>面向知识图谱的推理<ul><li>主要围绕关系的推理展开</li><li>主要能够辅助推理出新的事实、新的关系、新的公理以及新的规则等</li></ul></li><li>知识图谱的推理的主要技术分为两大类：<ul><li>基于演绎的知识图谱推理</li><li>基于归纳的知识图谱推理</li></ul></li></ul><h2 id="基于演绎的知识图谱推理">7.1 基于演绎的知识图谱推理</h2><ul><li>演绎推理的过程需要明确定义的先验信息，所以基于演绎的知识图谱推理多围绕本体展开</li></ul><h3 id="本体推理">7.1.1 本体推理</h3><ul><li>本体中包含了描述实体类别的概念以及关系之间的从属信息等，从而引发了一些实用的推理问题<ul><li>概念包含</li><li>概念互斥</li><li>概念可满足</li><li>全局一致</li><li>TBox一致。一个描述逻辑表示知识库主要由TBox和ABox两部分组成。TBox定义了特定知识领域的结构并包含一系列公理，可以通过已有概念构成新的概念。ABox包含了TBox中概念的实例</li><li>实例测试。判断个体是否是概念的实例</li><li>实例检索。找出某一概念在知识库中的所有实例</li></ul></li></ul><h4 id="a.-基于-tableaux表运算-的本体推理方法">a. 基于 Tableaux（表运算） 的本体推理方法</h4><ul><li><strong>OWL DL 处于 OWL 和基于 Tableaux（表运算） 的本体推理的交集之中</strong></li><li>OWL DL 基于描述语言，无法表示 <code>if ... then ...</code> 形式的规则</li><li>是描述逻辑知识库一致性检测的最常用方法</li><li>通过一系列规则，构建 ABox，以检测可满足性，或者检测某一实例是否存在某概念。</li><li>工具：<code>~Page 286~</code><ul><li>FaCT++<ul><li><strong>可以与 protege 集成</strong></li><li>基于 OWL API</li></ul></li><li>Racer<ul><li>支持 OWL DL，以及部分 OWL 2 DL</li></ul></li><li>Pellet<ul><li><strong>支持 Jena 接口</strong></li><li>支持 OWL DL 的所有特性</li></ul></li><li>HermiT<ul><li>基于超标运算，更加高效</li><li>支持 OWL 2 规则</li></ul></li></ul></li></ul><div class="figure"><img src="/2020/06/25/knowledge-graph-book/本体推理工具.png" alt="本体推理工具"><p class="caption">本体推理工具</p></div><h3 id="基于逻辑编程的推理方法">7.1.2 基于逻辑编程的推理方法</h3><ul><li>逻辑编程是一族基于规则的知识表示语言</li><li>规则推理具有更大的灵活性</li><li>逻辑编程的研究始于 Prolog 语言<ul><li>该语言程序运行结果依赖规则内部的原子顺序和规则之间的顺序，因此不是完全的声明式的</li></ul></li><li>为了得到完全的声明式规则语言，开发了 <strong>Datalog</strong> 语言，其基本是 Prolog 的一个子集</li></ul><h4 id="a.-datalog-语言">a. Datalog 语言</h4><ul><li><strong>OWL RL 和 RDFS 处于 OWL 和 Datalog 的交集之中</strong></li><li><strong>Datalog 规则</strong>形如下式，其中 <span class="math inline">\(H\)</span> 为头部原子，<span class="math inline">\(B_1,B_2,\cdots,B_m\)</span> 为体部原子。描述的含义为：当体部原子都为真时，头部原子也应为真</li></ul><p><span class="math display">\[H\text{:-}B_1,B_2,\cdots,B_m\]</span></p><ul><li><p><strong>Datalog 事实</strong>： <span class="math inline">\(F(c_1, c_2, \cdots, c_n) \text{:-}\)</span></p></li><li><p><strong>推理工具：</strong></p><ul><li>RDFox<ul><li>支持基于内存的并行 Datalog 推理，支持 SPARQL 查询</li></ul></li></ul></li></ul><div class="figure"><img src="/2020/06/25/knowledge-graph-book/逻辑编程推理工具.png" alt="逻辑编程推理工具"><p class="caption">逻辑编程推理工具</p></div><h3 id="基于查询重写的推理方法">7.1.3 基于查询重写的推理方法</h3><h4 id="b.-本体介导的查询回答ontology-mediated-query-answeringomq">b. 本体介导的查询回答（Ontology-Mediated Query Answering，OMQ）</h4><ul><li>针对直接在知识图谱之上的查询</li><li>查询重写的任务是将一个本体 TBox <span class="math inline">\(T\)</span> 上的查询 <span class="math inline">\(q\)</span> 重写为查询 <span class="math inline">\(q_T\)</span>，使得对于任意的 ABox <span class="math inline">\(A\)</span>，<span class="math inline">\(q_T\)</span> 在 <span class="math inline">\(A\)</span> 上的执行结果等价于 <span class="math inline">\(q\)</span> 在 <span class="math inline">\((T,A)\)</span> 上的执行结果</li></ul><h4 id="a.-基于本体的数据访问ontology-based-data-access-obda">a. 基于本体的数据访问（Ontology-based Data Access, OBDA）</h4><ul><li>针对数据存储在外部的数据库中，如关系数据库</li><li>需要使用如 R2RML 语言，将数据映射为一个知识图谱</li><li>OBDA 框架包含外延和内涵两个部分<ul><li>外延层为符合某个数据库架构 <span class="math inline">\(S\)</span> 的一个源数据库 <span class="math inline">\(D\)</span></li><li>内涵层为一个 OBDA 规范 <span class="math inline">\(P=(T,M,S)\)</span> ，<span class="math inline">\(T\)</span> 为本体， <span class="math inline">\(S\)</span> 为数据源模式， <span class="math inline">\(M\)</span> 为 <span class="math inline">\(S\)</span> 到 <span class="math inline">\(T\)</span> 的映射</li></ul></li><li>虚拟 OBDA 的映射过程中不需要真正生成三元组，而是通过查询重写的方式来实现，将本体层面的 SPARQL 查询重写为在原始数据上的 SQL 查询</li></ul><h4 id="c.-工具-page-300">c. 工具 <code>Page 300</code></h4><div class="figure"><img src="/2020/06/25/knowledge-graph-book/查询重写推理工具.png" alt="查询重写推理工具"><p class="caption">查询重写推理工具</p></div><ul><li>Ontop<ul><li>兼容 RDFS、OWL 2 QL、R2RML、SPARQL</li><li>支持主流关系数据库</li><li>具有 protege 插件，可以编辑映射和测试查询</li></ul></li><li>Mastro<ul><li>支持 OWL2 QL 本体推理</li><li>仅支持与合取查询相对应的 SPARQL 的受限片段</li></ul></li><li>Stardog<ul><li>集成了 Ontop 代码，支持虚拟 RDF 图上的 SPARQL 查询</li></ul></li><li>Ultrawrap<ul><li>支持对具有反向和传递属性的 RDFS 扩展的判断</li></ul></li><li>Morph-RDB<ul><li>不支持本体层面的推理能力</li></ul></li></ul><h3 id="基于产生式规则的方法">7.1.4 基于产生式规则的方法</h3><ul><li>产生式系统是一种前向推理系统，可以按照一定机制执行规则</li><li>一个产生式系统由事实集合、产生式集合和推理引擎三部分组成<ul><li>事实集合<ul><li>事实可以描述对象，形如 <code>(type attr_1:val_1 attr_2:val_2 ... attr_n:val_n)</code>，其中 <code>type, attr_i, val_i</code> 均为<strong>原子</strong>（代表常量）</li><li>事实也可以描述关系，形如 <code>(basicFact relation:olderThan firstArg:John secondArg:Alice)</code></li></ul></li><li>产生式集合<ul><li>由一系列的<strong>产生式</strong>组成，形如 <code>IF conditions THEN actions</code> ，其中 <code>conditions</code> 是条件组成的集合，且各条件之间为且的关系，又称 LHS； <code>actions</code> 是动作组成的序列，又称 RHS</li><li>LHS 中每个条件形如 <code>(type attr_1:spec_1 ... attr_n:spec_n)</code> ，其中 <code>spec_i</code> 代表对 <code>attr_i</code> 的约束，比如<ul><li>原子 <code>(person name:Alice)</code></li><li>变量 <code>(person name:x)</code></li><li>表达式 <code>(person age:[n+4])</code></li><li>布尔测试 <code>(person age:{&gt;10})</code></li><li>约束的与、或、非、操作</li></ul></li><li>RHS 是 action 的序列，执行时依次执行，动作有三类：<ul><li><code>ADD pattern</code>。向运行内存中加入形如 pattern 的事实</li><li><code>REMOVE i</code>。从运行内存中移除当前规则第 <code>i</code> 个条件匹配的事实</li><li><code>MODIFY i (attr spec)</code>。对当前规则第 <code>i</code> 个条件匹配的事实，将其对应于 <code>attr</code> 属性的值修改为 <code>spec</code></li></ul></li></ul></li><li>推理引擎<ul><li>模式匹配<ul><li>匹配每条规则的条件部分匹配当前的运行内存中的事实</li><li>Rete 算法</li></ul></li><li>选择规则<ul><li>按一定策略从被触发的多条规则中选择一条</li><li>随机选择</li><li>规则的具体性。如 <code>(Student name:)=&gt;</code> 和 <code>(Student name: age:20)=&gt;</code> 相比，第二条规则更加具体</li><li>新近程度。选择最近没有触发的规则</li></ul></li><li>执行规则<ul><li>执行被选择的规则的 RHS，从而操作运行内存</li></ul></li></ul></li></ul></li><li>工具<ul><li>Drools <code>~Page 327~</code><ul><li>其规则引擎实现了数据同逻辑的完全解耦</li></ul></li><li>Jena<ul><li>基于 RDFS 推理机和 OWL 推理机</li><li>可以完成上下位推理、类别推理等推理任务</li></ul></li><li>GraphDB。基于 RDF4J ，支持 RDFS、OWL、DLP、OWL Horst、OWL 2 RL 等多种语言</li></ul></li></ul><div class="figure"><img src="/2020/06/25/knowledge-graph-book/产生式规则推理工具.png" alt="产生式规则推理工具"><p class="caption">产生式规则推理工具</p></div><h2 id="基于归纳的知识图谱推理">7.2 基于归纳的知识图谱推理</h2><h3 id="基于图结构的推理">7.2.1 基于图结构的推理</h3><ul><li>路径是一种重要的进行关系推理的信息，实体的邻居节点以及它们之间的关系是描述一个实体的重要信息</li><li>在知识图谱推理的研究中，常考虑的是实体一跳和两跳范围内的节点和关系</li><li><strong>PRA（Path Ranking Algorithm）</strong><ul><li>利用实体节点之间的路径进行链接预测推理</li><li>将关系推理（包括头实体链接预测、尾实体链接预测）转化为排序问题，对每个关系的头实体预测和尾实体预测都单独训练一个排序模型</li><li><strong>随机游走的路径排序算法</strong> <code>~Page 308~</code><ul><li><strong>路径特征搜索</strong>中增加了对有效路径的约束，以减少搜索空间<ul><li>路径在知识图谱中的支持度应大于某设定的比例<ul><li>支持是指：当对路径<span class="math inline">\(P\)</span> 上 的任何一个实体 <span class="math inline">\(t\)</span> 都有 <span class="math inline">\(s_{h,P}(t) \ne 0\)</span> 时，则称一个查询实体 <span class="math inline">\(h\)</span> 支持一个路径 <span class="math inline">\(P\)</span> ，</li><li>支持度 <span class="math inline">\(\alpha\)</span> 是指：要求任何一个生成的节点需要被至少 <span class="math inline">\(\alpha\)</span> 比例的训练集中的查询实体 <span class="math inline">\(h_i\)</span> 所支持</li></ul></li><li>路径的长度小于或等于某设定长度</li><li>每条路径至少有一个正样本在训练集中</li><li><strong>路径随机采样方法</strong>：采集路径随机游走过程中，采用了 LVS（Low-Variance Sampling）方法<ul><li>LVS 利用一个随机数，生成所有的样本，而非在每次采集路径时，都随机采样</li></ul></li></ul></li><li>基于路径的随机游走定义了一个关系路径的分布，并得到每条<strong>路径的特征值</strong> <span class="math inline">\(s_{h,P}(t)\)</span>，其可以理解为沿路径 <span class="math inline">\(P\)</span> 从 <span class="math inline">\(h\)</span> 到达 <span class="math inline">\(t\)</span> 的概率</li><li>当 <span class="math inline">\(h=t\)</span> 时， <span class="math inline">\(s_{h,P}(t)\)</span> <strong>初始化</strong>为 1，否则初始化为 0</li><li>随机游走过程中，<strong><span class="math inline">\(s_{h,P(t)}\)</span> 的更新规则</strong>如下，其中 <span class="math inline">\(P(t|t&#39;;r_l)=\frac{r_l(t&#39;, t)}{r_l(t&#39;,\cdot)}\)</span> 表示从节点 <span class="math inline">\(t&#39;\)</span> 出发，沿着关系 <span class="math inline">\(r_l\)</span>，通过一步的游走能够到达节点 <span class="math inline">\(e\)</span> 的概率</li></ul></li></ul><p><span class="math display">\[s_{h,P}(t)=\sum_{t&#39; \in range(P&#39;)} s_{h,P&#39;}(t&#39;) \cdot P(t|t&#39;;r_l)\]</span></p><pre><code>* 一个头实体和尾实体的组合的**得分计算**方法如下，其中 $P_r$ 为关系 $r$ 对应的路径集合，$\theta_i$ 为待训练参数：</code></pre><p><span class="math display">\[score(h,t)=\sum_{P_i \in P_r} \theta_i s_{h,P_i}(t)\]</span></p><pre><code>* 通过一个**逻辑回归**得到每个样本的概率</code></pre><ul><li><strong>传统 PRA 中路径是连续的，且路径中的关系是同向的</strong></li><li>CoR-PRA <code>~Page 309~</code> 通过改变 PRA 的路径特征搜素策略，促使其能够涵盖更多的语义信息，主要是处理路径中有常量的情况<ul><li>与 PRA 相比，CoR-PRA 增加了带有常量的路径搜索，且搜索过程由单向搜索变成了双向搜索</li></ul></li><li>工具<ul><li><a href="https://github.com/noon99jaki/pra" target="_blank" rel="noopener">PRA</a></li></ul></li></ul></li></ul><h3 id="基于规则学习的推理">7.2.2 基于规则学习的推理</h3><ul><li>关键是自动化的规则学习，有规则主体的信息可以推断出规则头的信息</li></ul><p><span class="math display">\[\text{rule: head}\leftarrow \text{body}\]</span></p><ul><li>规则头由一个二元的原子（包含了变量的元组）构成，而规则主体由一个或多个一元或二元原子组成</li><li>知识图谱规则学习方法中，研究较多的有两类：<ul><li><strong>规则主体中的原子可以以肯定或否定的形式出现</strong>。但是如果规则主体中只包含有肯定形式的原子，而不含否定形式的原子，称这样的规则为<strong>霍恩规则</strong></li><li><strong>路径规则</strong>是霍恩规则的子集，其规则主体中的原子只含有二元原子，且规则主体的所有二元原子构成一个规则头中的两个实体之间的路径</li></ul></li></ul><h4 id="a.-规则的评估方法">a. 规则的评估方法</h4><ul><li>支持度（support）<ul><li>满足规则主体和规则头的实例个数</li><li><span class="math inline">\(\text{support(rule)}\)</span></li><li>支持度越大，规则的实例在知识图谱中越多，统计上来看，越可能是一个较好的规则</li></ul></li><li>置信度（confidence）<ul><li>支持度和满足规则主体的实例个数的比值</li><li><span class="math inline">\(\text{confidence(rule)}=\frac{\text{support(rule)}}{\text{ #body(rule)}}\)</span></li><li>置信度越高，规则的质量越高</li><li>上述置信度间接假设了不存在知识图谱中的三元组是错误的，这是不合理的</li><li><strong>基于部分完全假设（partial completeness assumption，PCA）的置信度</strong>，考虑了<strong>知识图谱的不完整性</strong><ul><li><span class="math inline">\(\text{confidence(rule)}=\frac{\text{support(rule)}}{\text{ #body(rule)} \wedge r_0(x, y&#39;)}\)</span></li><li>此处 <span class="math inline">\(r_0(x, y)\)</span> 是规则头，而 <span class="math inline">\(r_0(x, y&#39;)\)</span> 说明在知识图谱中，只要规则头中的头实体 <span class="math inline">\(x\)</span> 通过关系 <span class="math inline">\(r_0\)</span> 连接到除 <span class="math inline">\(y\)</span> 以外的实体时，才能算进分母的计数</li><li><strong>motivation</strong>：如果头实体 <span class="math inline">\(x\)</span> 和关系 <span class="math inline">\(r_0\)</span> 没有在知识图谱中构成相关的三元组，而通过规则主体可以推出三元组 <span class="math inline">\(r_0(x,y)\)</span> ，那么根据知识图谱的不完全假设，<span class="math inline">\(r_0(x,y)\)</span> 只是在知识图谱中缺失而不是错误的三元组，所以不应该将这类实例化的例子计算在分母中</li></ul></li></ul></li><li>规则头覆盖度（head coverage）<ul><li>规则支持度和满足规则头的实例个数的比值</li><li><span class="math inline">\(\text{HC(rule)}=\frac{\text{support(rule)}}{\text{ #head(rule)}}\)</span></li><li>规则头覆盖度越高，规则的质量越高</li></ul></li></ul><h4 id="b.-常见算法">b. 常见算法</h4><ul><li><strong>AMIE</strong><ul><li>挖掘的是霍恩规则，也是一种闭环规则，即整条规则可以在图中构成一个闭环结构</li><li>挖掘算子<ul><li>增加悬挂原子（adding dangling atom）。在一个规则中增加一个原子，这个原子包含一个新的变量和一个已经在规则中出现的元素，可以是出现过的变量，也可以是出现过的实体</li><li>增加实例化的原子（adding instantiated atom）。在规则中增加一个原子，这个原子包含一个实例化的实体以及一个已经在规则中出现的元素</li><li>增加闭合原子（adding closing atom）。在规则中增加一个原子，其包含的两个元素都是已经出现在规则中的变量或实体。增加闭合原子后，规则构建完成</li></ul></li><li>剪枝策略<ul><li>设置最低规则头覆盖度过滤<ul><li>AMIE 用对知识图谱的查询来筛选合适的选项</li></ul></li></ul></li></ul><p><span class="math display">\[  \text{SELECT}\quad ?r\quad \text{WHERE}\quad a_0 \wedge a_1 \wedge \dots \wedge a_n \wedge ?r(X,Y) \\  \text{HAVING COUNT}(a_0)\ge k  \]</span></p><pre><code>* 在一条规则中，每在规则主体中增加一个原子， 都应使规则的置信度增加</code></pre></li></ul><h4 id="c.-工具">c. 工具</h4><ul><li><a href="http://www.mpi-inf.mpg.de/departments/ontologies/projects/amie/" target="_blank" rel="noopener">AMIE 和 AMIE+</a>，<a href="https://github.com/lajus/amie" target="_blank" rel="noopener">github</a></li></ul><h3 id="基于表示学习的推理">7.2.3 基于表示学习的推理</h3><ul><li>将知识图谱中的实体和关系映射到一个连续的向量空间</li><li>受到自然语言处理关于词向量的研究的启发，word2vec 中发现了词向量的空间平移性，扩展到知识图谱可以理解为拥有同一种关系的头尾实体对，在向量空间的表示可能具有平移不变性</li></ul><h4 id="a.-常见算法-page-319">a. 常见算法 <code>~Page 319~</code></h4><ul><li><strong>TransE</strong><ul><li><strong>翻译假设</strong>：理想下，每个存在知识图谱中的三元组都满足 <span class="math inline">\(h+r=t\)</span></li><li>三元组得分函数为</li></ul></li></ul><p><span class="math display">\[  f(h,r,t)=||h+r-t||_{L_1/L_2}  \]</span></p><pre><code>* 损失函数为</code></pre><p><span class="math display">\[  L=\sum_{(h,r,t)\in S}\sum_{(h&#39;,r,t&#39;)\in S&#39;_{(h,r,t)}}[\gamma + f(h,r,t) - f(h&#39;,r,t&#39;)] \\\\  S&#39;_{(h,r,t)}=\{(h&#39;, r, t)| h&#39; \in E\} \cup \{(h, r, t&#39;)| t&#39; \in E\}  \]</span></p><pre><code>* 存在表达能力不足的问题    * 知识图谱中的关系可以分为一对一、一对多、多对一、多对多，这 4 种类型    * TransE 无法很好的捕捉一对多、多对一、多对多类型的关系</code></pre><ul><li>TransH</li><li>TransR</li><li><strong>DistMult</strong><ul><li><strong>线性映射假设</strong>：理想下，每个存在知识图谱中的三元组都满足 <span class="math inline">\(hM_r=t\)</span></li><li>三元组得分函数为</li></ul></li></ul><p><span class="math display">\[  f(h,r,t)=hM_rt^T  \]</span></p><pre><code>* 当关系的矩阵设计为对角矩阵时，参数量与 TransE 相同，且效果比普通矩阵更好。因此，DistMult 系列方法中，常常将关系的表示设置为对角矩阵* 当关系设计为对角矩阵时，天然地假设了所有的关系是对称关系</code></pre><ul><li>ComplEX<ul><li>将基于实数的表示学习扩展到了复数，从而克服 DistMult不能很好地表示非对称关系的问题</li><li>得分函数，<span class="math inline">\(Re(x)\)</span> 代表 <span class="math inline">\(x\)</span> 的实部，<span class="math inline">\(Im(x)\)</span> 代表 <span class="math inline">\(x\)</span> 的虚部，<span class="math inline">\(&lt;x,y,z&gt;=xyz\)</span></li></ul></li></ul><p><span class="math display">\[  \begin{eqnarray}  f(h,r,t)&amp;=&lt;Re(h), Re(e), Re(t))&gt;+&lt;Re(h), Im(e), Im(t))&gt; \\  &amp;+&lt;Im(h), Re(e), Im(t))&gt;-&lt;Im(h), Im(e), Im(t))&gt;  \end{eqnarray}  \]</span></p><h4 id="b.-评价指标">b. 评价指标</h4><ul><li>平均排序（mean rank，MR）<ul><li>测试集中真实的尾实体，在预测实体所处的位置的平均值</li></ul></li><li>倒数平均排序（mean reciprocal rank，MRR）<ul><li>真实的尾实体在预测实体所处的位置的倒数的和的平均值</li></ul></li><li>排序 n 以内的占比（Hit@n）<ul><li>真实的尾实体在预测实体所处的位置小于 n 的比例</li></ul></li></ul><h4 id="c.-工具-1">c. 工具</h4><ul><li>清华开源的 OpenKE</li></ul><hr><h1 id="语义搜索">8. <a id="8">语义搜索</a></h1><ul><li>信息检索包括面向文档的检索（Document retrieval）和面向数据的检索（data retrieval）<ul><li>面向数据的检索包括基于数据库的检索和基于知识库的检索</li><li>差异体现在：用户需求表示（query model）、底层数据表示（data model）、匹配技术（matching technique）</li></ul></li><li>面向文档的信息检索主要通过轻量级的语法模型（lightweight syntax-centric model）表示用户的检索需求和资源的内容<ul><li>面向文档的信息检索主要使用关键词模式检索，是一个<strong>词袋模型</strong>，对主题搜索效果好，但无法应对更加复杂的信息检索要求</li></ul></li><li>面向数据的检索属于重量级语义搜索系统，因为其采用显示的和形式化的模型</li><li><strong>语义</strong>关注的是能用于搜索的资源的含义<ul><li>语言学模型：词语级别的关系建模、分类以及构建同义词库</li><li>概念模型：语法元素的关系建模以及从语法元素到论域的映射</li></ul></li><li><strong>语义模型</strong>的性质：<ul><li>具备表达能力，即语言和建模结构的数量</li><li>能够形式化，即解析过程必须是可计算的</li><li>不同语义模型的搜索技术也不同</li></ul></li><li><strong>最先进的语义搜索系统结合了一系列技术</strong>：结构化查询语言的构建、基于统计的信息检索排序方法、有效索引和查询处理的数据库方法以及复杂推理等技术</li><li><strong>语义搜索的核心在于查询的构建和理解</strong></li></ul><h2 id="结构化的查询语言">8.1 结构化的查询语言</h2><h3 id="sparql-to-3.2-page-337">8.1.1 SPARQL <a href="#3.2">(To 3.2)</a> <code>~Page 337~</code></h3><ul><li>多个 SPARQL 三元组模式组成的集合称作<strong>基本图模式</strong>（Basic Graph Pattern，BGP）</li><li>SPARQL 查询包括查询、插入和删除操作</li></ul><h4 id="a.-查询">a. 查询</h4><ul><li><code>SELECT</code>，唯一可以返回图模式匹配的具体结果给用户的形式</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 过滤条件可选</span><br><span class="line">SELECT 变量</span><br><span class="line">WHERE &#123;基本图模式 [过滤条件]&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>ASK</code>，测试知识图谱中是否存在满足给定查询约束条件的数据，结果返回 <code>Yes</code> 或 <code>No</code><ul><li>其后面的内容与 <code>SELECT</code> 中的 <code>WHERE</code> 相似</li></ul></li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 条件约束 可选</span><br><span class="line">ASK &#123;基本图模式 [条件约束]&#125;</span><br><span class="line"></span><br><span class="line">ASK &#123; ?person name &quot;Tim Burton&quot;&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>CONSTRUCT</code>，将图模式匹配结果生成新的 RDF 图</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CONSTRUCT &#123;</span><br><span class="line">    ?person type director .</span><br><span class="line">    ?person type person</span><br><span class="line">&#125;</span><br><span class="line">WHERE &#123;</span><br><span class="line">    ?person name &quot;Tim Burton&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>DESCRIBE</code>，查询与制定 IRI 相关的数据，和 <code>SELECT</code> 有所区别，其返回资源的所有信息</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># DESCRIBE后可以直接使用 IRI，也可以使用变量标识</span><br><span class="line"># 过滤条件可选</span><br><span class="line"># WHERE部分为可选项，返回资源的所有信息</span><br><span class="line">DESCRIBE IRI 或 变量</span><br><span class="line">WHERE &#123;基本图模式 [过滤条件]&#125;</span><br><span class="line"></span><br><span class="line">DESCRIBE ?person</span><br><span class="line">WHERE &#123;?person name &quot;Tim Burton&quot;&#125;</span><br><span class="line"></span><br><span class="line">######### output #########</span><br><span class="line">p2556 name &quot;Tim Burton&quot;</span><br><span class="line">f1342 director p2556</span><br><span class="line">f1336 director p2556</span><br><span class="line">f1333 director p2556</span><br></pre></td></tr></table></figure></p><h4 id="b.-插入">b. 插入</h4><ul><li><code>INSERT DATA</code>，插入一个或多个三元组</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSERT DATA &#123;RDF 三元组&#125;</span><br><span class="line"></span><br><span class="line"># &quot;;&quot; 用来连续插入头实体相同的三元组</span><br><span class="line">INSERT DATA &#123;</span><br><span class="line">    f1333 released 1999;</span><br><span class="line">          type film;</span><br><span class="line">          language English</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="c.-删除">c. 删除</h4><ul><li><code>DELETE DATA</code>，删除一个或多个三元组，语法与 <code>INSERT DATA</code> 类似</li></ul><p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE DATA &#123;RDF 三元组&#125;</span><br></pre></td></tr></table></figure></p><h2 id="语义数据搜索">8.2 语义数据搜索</h2><div class="figure"><img src="/2020/06/25/knowledge-graph-book/语义搜索流程.png" alt="语义搜索流程"><p class="caption">语义搜索流程</p></div><ul><li>链接数据比较成熟的语义搜索主要包括<ul><li>面向本体的搜索引擎：Swoogle、Watson</li><li>面向实体的搜索引擎：Sigma on Sindice、FalconS</li><li>面向细粒度数据 Web 的搜索引擎：SWSE、Hermes（SearchWebDB）</li></ul></li><li>上述搜索引擎的基本组成都包括了三元组存储、索引构建、查询处理及排序等<ul><li>三元组存储<ul><li>基于信息检索（IR）的存储方式，针对文本数据进行排序检索来优化</li><li>基于 DB 的存储方式，具有各种索引和查询算法，以适应各种对结构化数据的复杂查询</li><li>原生存储（Native Stores），直接以 RDF 图形式的存储方式</li></ul></li><li>索引构建<ul><li>目前主要的方式都是重用 IR 索引来索引语义数据。它的核心想法是将RDF转换称具有fields 和terms的虚拟文档。</li><li>增量索引</li></ul></li><li>查询处理和排序<ul><li>给定查询输入，将其构建成复杂的结构化查询</li><li><strong>排序通常需要考虑以下原则</strong>：<ul><li>质量传播（Quality Propagation）。通过更新一个元素的分数（一种质量度量），来反应该元素的相邻元素的质量</li><li>数量聚合。考虑元素邻居的数量</li></ul></li></ul></li></ul></li></ul><h2 id="语义搜索的交互范式">8.3 语义搜索的交互范式</h2><ul><li>理解用户的<strong>查询意图</strong>在于将用户的查询输入构建成结构化的查询语言 SPARQL</li><li><strong>交互范式</strong>主要包括：关键词查询、自然语言查询、分面查询、表单查询、可视化查询以及混合方式查询等</li></ul><h3 id="基于关键词的知识图谱语义搜索方法">8.3.1 基于关键词的知识图谱语义搜索方法</h3><ul><li><strong>基于关键词直接在知识图谱上搜索答案</strong><ul><li>核心思想是采用知识图谱子图定位的策略</li><li>关键是建立有效的关键词和知识图谱子图的索引，以获得候选的知识图谱子图</li><li><strong>索引构建</strong>的方式：<ul><li>关键词倒排索引，定位包含关键词的实体</li><li>摘要索引，构建包含结构化查询实体和关系类别的索引</li><li>路径索引，借助关键词中包含的查询起始和终止结点，在图上按路径搜索</li></ul></li><li>主要解决查询答案仅出现在单条知识图谱三元组中，对复杂的语义查询往往无法适用</li></ul></li><li><strong>基于关键词生成结构化的查询</strong><ul><li>将关键词集合转化为结构化查询<ul><li>关键词映射。构建关键词和知识图谱实体和边的索引</li><li>后续结构化查询构建。基于生成的实体和关系扩展，生成局部的知识图谱子图；根据查询意图，将局部子图中的部分实体和关系替换为变量</li><li>候选结构化查询排序。可以基于关键词搜索相似度、实体的拓扑度分布等指标来计算排序评分</li></ul></li></ul></li></ul><h3 id="基于分面的知识图谱语义搜索方法">8.3.2 基于分面的知识图谱语义搜索方法</h3><ul><li>分面可以看做属性或一组分类体系，或定义为某个主题的维度或侧面</li><li>具体到知识图谱上的分面搜索，可以根据 RDF 三元组定义分面和值，即分面可以被看做一个在当前结果集中的 RDF 资源（实体）的属性，这些属性的 object 是分面的值</li><li>分面应该以非常小的、相等的进度引导用户进行搜索</li><li>Dataplorer</li></ul><h3 id="基于表示学习的知识图谱语义搜索方法">8.3.3 基于表示学习的知识图谱语义搜索方法</h3><ul><li>旨在通过机器学习技术，将知识图谱中的实体和关系投射到连续低维的向量空间中，同时保持原有知识图谱的基本结构和性质</li><li>优势：<ul><li>相似度可以直接通过欧氏距离度量</li><li>学习到了局部特征和全局特征，蕴含语义更丰富，可以进行高效的查询推理</li></ul></li><li>基于表示学习的结构化语义查询<ul><li>近似语义搜索</li><li>基于查询图，利用翻译机制等表示学习算子计算查询目标在向量空间中的坐标</li></ul></li><li>基于表示学习的自然语言语义查询<ul><li>处理短语到知识图谱上实体或边的映射，消除歧义，实现查询图的构建</li><li>离线阶段实现短语词典与知识图谱中的实体和关系在向量空间的对齐</li><li>线上阶段，通过关键词检索发现候选实体和边的集合，然后将每一个候选实体集合中的实体的平均实值向量作为查询图生成的实体表示</li></ul></li><li>表示学习技术为知识图谱的语义搜索服务所面临的 3 项挑战：<ul><li>最近邻搜索效率问题</li><li>链接预测的合取问题。搜索目标受多个实体和关系共同约束时的问题</li><li>结果可解释性问题</li></ul></li></ul><h2 id="开源工具elasticsearchpage-357">8.4 <a id="8.4">开源工具（Elasticsearch）</a><code>~Page 357~</code></h2><ul><li>可以按照名称搜索实体、实体属性、多跳搜索以及搜索符合多对属性要求的实体</li><li>Elasticsearch 要求文档的输入格式为 json，对于数据集中的<strong>一个实体</strong>的所有属性和属性值汇总在一起，存储在<strong>一个 json 对象</strong>中，作为<strong>一篇文档</strong>导入 Elasticsearch。对每个实体都各自产生各自的 json 文档<ul><li>这样针对多对（属性，属性值）联合检索的情况，可以提高检索效率</li></ul></li><li><strong>对于需要支持范围搜索的属性，要单独考虑。</strong> <code>~Page 358~</code></li><li>可以使用<strong>属性同义词扩展</strong>处理一个属性有多种字面表达的情况</li></ul><hr><h1 id="知识问答">9. <a id="9">知识问答</a></h1><ul><li>以自然语言问答为交互形式，从智能体获取知识</li><li><strong>知识问答、信息检索以及数据库查询的比较</strong></li></ul><div class="figure"><img src="/2020/06/25/knowledge-graph-book/知识问答特点.png" alt="知识问答特点"><p class="caption">知识问答特点</p></div><h2 id="知识问答的分类">9.1 知识问答的分类</h2><h3 id="问题类型与答案类型">9.1.1 问题类型与答案类型</h3><ul><li>问题分类体系很大程度上按照目标答案的差异而区分</li><li><strong>除问题类型，还需要关注</strong><ul><li><strong>问题焦点</strong>：问句中出现的与答案实体或属性相关的元素</li><li><strong>问题主体</strong>：反映问题关于哪些主体</li></ul></li></ul><h4 id="a.-事实型客观问题">a. 事实型客观问题</h4><ul><li>特点：<ul><li>语法结构简单。明确的主谓宾结构，不包括并列、否定等复杂结构</li><li>语义结构清晰</li></ul></li><li>细分：<ul><li>询问命名实体的基本定义<ul><li>事物的分类</li><li>事物的别名</li><li>事物的定义</li></ul></li><li>询问实体属性<ul><li>人</li><li>地点</li><li>时间</li><li>属性</li></ul></li><li>复杂知识图谱查询<ul><li>实体列表或统计结果</li><li>实体差异</li><li>实体关系</li></ul></li></ul></li></ul><h4 id="b.-主观深层次问题">b. 主观深层次问题</h4><ul><li>细分<ul><li>问解释</li><li>问方法</li><li>问专家意见</li><li>问推荐</li></ul></li></ul><h3 id="知识库类型">9.1.2 知识库类型</h3><ul><li>从知识库覆盖的领域来看<ul><li>领域相关的问答系统</li><li>领域无关的问答系统（开放知识库）</li></ul></li><li>从信息的组织格式来看<ul><li>非结构化文本类型知识库<ul><li>纯文本</li><li>常见问答对（FAQ）或社区问答</li></ul></li><li>半结构化<ul><li>网页</li></ul></li><li>结构化知识库<ul><li>电子表格</li><li>关系数据库</li><li>图数据库</li></ul></li><li>图片、音频、视频等媒体</li><li>机器学习模型</li></ul></li><li>从存储访问机制<ul><li>集中数据存储</li><li>分布式存储</li><li>基于互联网的全网数据（Linked Data）</li></ul></li></ul><h3 id="智能体类型">9.1.3 智能体类型</h3><ul><li>根据知识库表示形式的不同<ul><li>传统问答方法（符号表示）<ul><li>关键词检索</li><li>文本蕴含推理</li><li>逻辑表达式</li></ul></li><li>基于深度学习的问答方法（分布式表示）<ul><li>LSTM</li><li>注意力模型</li><li>记忆网络</li></ul></li></ul></li><li>传统问答方法，将问答过程切分为<strong>语义解析和查询</strong>两个步骤<ul><li>语义解析把语句转化为 SPARQL 查询语句</li></ul></li><li>基于深度学习的问答方法利用深度神经网络，将问题与知识库中的信息转化为向量表示，通过相似度匹配方式完成问题与答案的匹配</li></ul><h2 id="知识问答系统的评价方法">9.2 知识问答系统的评价方法</h2><h3 id="问答系统的评价指标-page-386">9.2.1 问答系统的评价指标 <code>~Page 386~</code></h3><h4 id="a.-功能评价指标">a. 功能评价指标</h4><ul><li>重点关注返回的答案<ul><li><strong>正确的答案应当同时具备正确度及完备度</strong></li><li>正确但内容不完整，称为不准确答案</li><li>没有足够证据及论证表明答案与问题相关性的，称为无支撑答案</li><li>答案与问题完全无关，则答案是错误的</li></ul></li><li><strong>评价指标：</strong><ul><li>正确性<ul><li>F1</li><li>P@1。第一个答案是否正确的比率</li></ul></li><li>精确度<ul><li>是否缺失信息</li><li>是否包含多余信息</li></ul></li><li>完整性</li><li>可解释性</li><li>用户友好性<ul><li>人工评分</li></ul></li><li>额外的评价维度<ul><li>根据答案类型设定额外的评价维度</li><li>semantic tractability。反应问答之间的词表差异性</li><li>answer locality。答案是否零碎地分布在不同的文本或数据集中</li><li>derivability。问题的答案是否是某种确定性答案，还是含蓄的、不确定的描述</li><li>semantic complexity。问题涉及的语义复杂程度</li></ul></li></ul></li></ul><h4 id="b.-性能评价指标">b. 性能评价指标</h4><ul><li>问答系统的响应时间（response time）<ul><li>一般问答系统的响应时间应控制在 1s 以内</li></ul></li><li>问答系统的故障率（error rate）<ul><li>限定时间内，系统返回错误或系统运行过程中发生错误的统计</li></ul></li></ul><h3 id="问答系统的评价数据集">9.2.2 问答系统的评价数据集</h3><ul><li>TREC QA：评价 IRQA<ul><li>主要针对基于搜索的问答解决方案</li><li>评价方法：<ul><li>1000个测试问题，由 1~3 人标注评价答案的正确性、精准度以及对应文章的支持度</li></ul></li></ul></li><li>TREC LIVE QA：评价 CQA<ul><li>评价方法：<ul><li>大约1000个测试问题，问题要求在 1min 内回答，所有答案由 1~3 人标注，并直接按答案质量打 <span class="math inline">\(\{0,1,2,3\}\)</span> 分</li></ul></li></ul></li><li>QALD：评价 KBQA<ul><li>Question answering on linked data</li><li>面向开放领域的多语种问答</li><li>面向专业领域的问答</li><li>结构化数据和文本数据混合的问答</li><li>海量数据的问答</li></ul></li><li>SQuAD<ul><li>大规模阅读理解数据集，每个问题的答案都是相应阅读段落的一段文字或跨度</li><li>评价指标：<ul><li>精准匹配</li><li>F1 值</li></ul></li></ul></li><li>Web Questions 数据集<ul><li>只提供了答案，没有相应的查询</li><li>简单问句多，复杂问句少</li></ul></li><li>Quora QA：评价问题相似度计算</li><li>SemEval：词义消岐评测<ul><li>推特情感与创造性语句分析</li><li>实体关联<ul><li>多人对话中的人物识别</li><li>面向事件的识别以及分析</li></ul></li><li>信息抽取<ul><li>关系抽取与分类</li><li>基于语义分析的时间标准化</li></ul></li><li>词汇语义学<ul><li>关注词的语义相异性，目标是预测一个词和其他词相异的判别属性</li></ul></li><li>阅读理解与推理<ul><li>利用常识完成文本阅读理解</li><li>通过推理方式对给定的由声明和理由组成的论点，从两个候选论据中选出正确的论据</li></ul></li></ul></li></ul><h2 id="知识问答系统">9.3 知识问答系统</h2><h3 id="nlidb早期的问答系统">9.3.1 NLIDB：早期的问答系统</h3><ul><li>NLIDB：natural language interface to data base</li><li>所使用的的知识库与关系数据库不同，更像是基于逻辑表达的知识库</li><li>将领域问题语义处理逻辑硬编码为特定的语法解析规则（模板或简单的语法树）</li><li>模块：<ul><li>实体识别（Named Entity Recognition）：领域词典</li><li>语义理解（Question2Query）：语法解析（POS）、动词分析（主动和被动）、语义映射规则</li><li>回答问题（Answer Processing）：查询、聚合</li></ul></li><li><strong>语义理解</strong>过程所采用的技术：<ul><li><strong>基于模式匹配（Pattern-Matching）</strong><ul><li>直接将问题映射到查询</li><li>模板中可以设置变量，表示某一个类型的实体</li><li>发展为 KBQA 中基于模板的语义理解方案</li></ul></li><li><strong>基于语法解析（syntactic parsing）</strong><ul><li>将自然语言的复杂语义转化为逻辑表达式</li><li>利用句法解析树的结果，根据人工生成的语义规则和领域知识来转化成一种中间层的逻辑表达式</li><li>中间表示语言承载了高层次世界概念以及用户问题的含义，独立于数据库存储结构，可以依靠一系列转换规则，进一步转换成数据查询的表达式从而获取答案</li><li>演进为 KBQA 中基于语义解析（semantic parsing）的语义理解方法</li></ul></li></ul></li></ul><h3 id="irqa基于信息检索的问答系统">9.3.2 IRQA：基于信息检索的问答系统</h3><ul><li><strong>核心思想</strong>是：根据用户输入的问题，结合自然语言处理以及信息检索技术，在给定<strong>文档集合或互联网网页</strong>中筛选出相关的文档，从结果文档内容抽取关键文本作为候选答案，最后对候选答案进行排序，返回最优答案</li><li><strong>流程</strong>：<ul><li>问题处理（question processing）<ul><li>明确指示检索的过滤条件（query formulation，问句转化为关键词检索）</li><li>答案类型判断（answer type detection）</li></ul></li><li>段落检索与排序（passage retrieval and ranking）<ul><li>先排序文档，后排序文档中的段落</li></ul></li><li>答案处理（answer processing）</li></ul></li></ul><h3 id="kbqa基于知识库的问答系统">9.3.3 KBQA：基于知识库的问答系统</h3><ul><li><strong>特指使用基于知识图谱解答问题的问答系统</strong></li><li>很多技术借鉴和沿用了 NLIDB 中的技术和研究成果</li><li>语义理解（Question2Query）中的关键步骤：<ul><li>问题分析<ul><li>利用词典、词性分析、分词、实体识别、语法解析树分析、句法依存关系分析等技术，提取<strong>问题的结构特征</strong></li><li>基于机器学习和规则提取<strong>问题类型和答案类型</strong></li></ul></li><li>词汇关联<ul><li>针对在问题分析阶段未形成实体链接的部分，形成与知识库的链接</li><li>包括关系属性、描述属性、实体分类</li></ul></li><li>歧义消解<ul><li>对候选词汇、查询表达式排序选优</li></ul></li><li>构建查询<ul><li>通过自定义转化规则将问题转化为查询语言表达式</li></ul></li></ul></li></ul><h3 id="communityqafaq-qa基于社区问答问答对匹配的问答系统">9.3.4 CommunityQA/FAQ-QA：基于社区问答/问答对匹配的问答系统</h3><ul><li>在问答库中搜索以往出现的相似问题，将其答案返回给用户</li><li><strong>核心</strong>是计算问题之间的语义相似性</li><li><strong>挑战</strong>：<ul><li>泛化。相同的语义在自然语言表达中有众多表示方式</li><li>歧义。两个近似的句子可以具有完全不同的语义</li></ul></li></ul><h3 id="hybrid-qa-framework混合问答系统框架">9.3.5 Hybrid QA Framework：混合问答系统框架</h3><ul><li><strong>针对问题</strong>：<ul><li>结构化的知识库中存储的知识总是有限的</li><li>非结构化文本抽取存在精度问题，且不容易支持复杂查询与推理</li></ul></li></ul><h4 id="a.-deepqairqa主导的混合框架">a. DeepQA：IRQA主导的混合框架</h4><ul><li>DeepQA 综合 IRQA 和 KBQA</li><li>处理流程分为 4 个阶段：<ul><li>问题处理<ul><li>理解问题的类型，解析问题语义元素</li></ul></li><li>候选答案生成<ul><li>从网络上搜索相关文档并抽取答案，同时从知识库中查询答案</li><li>合并答案</li></ul></li><li>候选答案评分<ul><li>对每个候选答案选取一些重要特征（答案的类型、答案中的时空信息）</li><li>对特征打分，并形成答案的特征向量</li></ul></li><li>答案融合及排序<ul><li>把相同的答案进行融合</li><li>对新的答案候选集进行再排序</li><li>由训练好的逻辑回归分类器计算候选答案的置信度，返回置信度高的作为最终答案</li></ul></li></ul></li></ul><h4 id="b.-qald-hybrid-qakbqa主导的混合框架">b. QALD-Hybrid-QA：KBQA主导的混合框架</h4><ul><li>同时利用知识图谱数据和文本数据</li><li>将自然语言问句均转化为 SPARQL<ul><li>此时并非所有 SPARQL 查询中的三元组特征都可以对应到知识图谱中的词汇</li><li>也并非所有知识都可以从知识图谱中查询到，有一部分知识需要从文档中抽取</li></ul></li></ul><h4 id="c.-frankenstein问答系统的流水线架构">c. Frankenstein：问答系统的流水线架构</h4><ul><li><p>只考虑了语义理解（Question2Query）中针对结构化查询的部分，未覆盖非结构化文本的问答</p></li><li>将 KBQA 分成基于 4 类核心模块的流水线<ul><li>命名实体识别与消解歧义（named entity disambiguation）</li><li>实体关系映射</li><li>实体分类映射。映射答案类型到知识库的实体分类上</li><li>构建查询</li></ul></li></ul><h2 id="基于知识库的问答系统kbqa">9.4 基于知识库的问答系统（KBQA）</h2><ul><li><strong>现存两大困难</strong>：<ul><li>现有的自然语言理解技术在处理自然语言的歧义性和复杂性方面比较薄弱</li><li>QA 系统需要大量的领域知识来理解自然语言问题</li></ul></li></ul><h3 id="挑战">9.4.1 挑战</h3><ul><li>多样的概念映射机制<ul><li>可选映射到三元组、限制条件、属性链条、复合属性、排序条件、歧义</li></ul></li><li>不完美的知识库<ul><li>未必全都是结构化的数据</li><li>知识组织机制不同</li><li>多语言</li><li>知识库本身不完整</li></ul></li><li>泛化语义理解的预期</li></ul><h3 id="技术-page-394">9.4.2 技术 <code>~Page 394~</code></h3><h4 id="a.-基于模板的方法">a. 基于模板的方法</h4><ul><li>定义了一组带变量的模板，直接匹配问题文本形成查询表达式</li><li>适用于处理只有一个查询条件的简单问题</li><li><strong>关键步骤</strong>为模板生成和模板实例化</li><li>缺点：<ul><li>创建的模板结构未必和知识图谱中的数据契合</li><li>对应一个问题的潜在模板数量非常多</li><li>手工准备模板的代价很大</li></ul></li></ul><h4 id="b.-基于语义解析的方法">b. 基于语义解析的方法</h4><ul><li>通过对自然语言查询的语法分析，将查询转换成逻辑表达式（查询图），然后利用知识库的语义信息将逻辑表达式转换成知识库查询，最终通过查询知识库得到查询结果</li><li>逻辑表达式<ul><li>带参数的原子逻辑表达式<ul><li>一元形式（unary），匹配实体</li><li>二元形式（binary），匹配实体之间的二元关系</li></ul></li><li>基于操作组合的复杂逻辑表达式<ul><li>连接（join）、交集（intersection）、聚合统计（aggregate）</li></ul></li></ul></li><li><strong>语法分析器</strong>通过数据集的训练，用于将自然语言转化为逻辑表达式<ul><li>两个关键步骤：<ul><li>资源映射</li><li>逻辑表达式生成。自底向上自动将自然语言查询解析为语法树，语法树的根节点即是最终对应的逻辑表达式</li></ul></li></ul><div class="figure"><img src="/2020/06/25/knowledge-graph-book/逻辑表达式生成过程.png" alt="逻辑表达式生成过程"><p class="caption">逻辑表达式生成过程</p></div></li><li><strong>逻辑表达式生成过程的 4 个问题</strong><ul><li>资源映射<ul><li>主要是关系映射</li></ul></li><li>桥接操作<ul><li>对于自然语言问句中关系模式模糊的情况，难以直接映射到知识库中</li><li>在知识库中查找所有潜在关系，进行桥接</li></ul></li><li>组合操作<ul><li>连接、求交以及聚合</li></ul></li><li>候选逻辑表达式评估</li></ul></li></ul><h4 id="c.-基于深度学习的传统问答模块优化">c. 基于深度学习的传统问答模块优化</h4><ul><li>改进语义解析、实体识别、意图分析、实体消岐等模块</li><li>语义解析部分比较复杂，需要基于问句生成对应的查询图，然后查询图在知识图谱上进行子图匹配<ul><li><strong>查询图可以直接映射到 Lambda Calculus 形式的逻辑表达式，并与 <span class="math inline">\(\lambda\)</span>-DCS（Lambda Dependency-Based Compositional Semantics）紧密相关，因此可以将语义解析的过程转换成查询图生成的过程</strong></li><li>查询图由 4 种节点组成：实体、中间变量、聚合函数、Lambda 变量（答案节点）</li><li><strong>查询图生成过程</strong>：<ul><li>选择一个主题实体作为根节点</li><li>确定一条从根节点到 Lambda 变量的有向路径（核心推断链），路径上可以有 1 个或多个中间变量。除根节点为实体，其他都只能是变量<ul><li>通过谓语序列，评估获取最优核心推断链</li></ul></li><li>给查询图添加约束条件和聚合函数</li></ul></li></ul></li></ul><h4 id="d.-基于深度学习的端到端问答模型">d. 基于深度学习的端到端问答模型</h4><ul><li>将问题和知识库中的信息均转化为向量表示，通过向量间的相似度计算方式，完成用户问题与知识库答案的匹配<ul><li>根据问题中的主题词，在知识库中确定候选答案</li><li>把问题和候选答案都映射到一个低维向量空间<ul><li>答案的映射可以包含如下特征：答案子图、答案路径、答案上下文、答案类型</li></ul></li><li>计算问题和候选答案向量的相似度得分</li></ul></li></ul><h2 id="开源工具">9.5 开源工具</h2><h3 id="elasticsearch-搭建简单知识问答系统-page-407">9.5.1 Elasticsearch 搭建简单知识问答系统 <code>~Page 407~</code></h3><ul><li><p>相比于 <a href="#8.4">(To 8.4)</a> <strong>增加了将自然语言问题转化为 Elasticsearch 对应逻辑表达式以及查询语句的过程</strong></p></li><li>自然语言问题的 4 种类型：<ul><li>实体检索</li><li>实体的属性检索</li><li>实体属性的多跳检索</li><li>多种属性条件检索实体</li></ul></li><li>书中构建了 3 种映射模板<ul><li>自然语言问题类型对应的逻辑表达式模板</li><li>查询类型与 Elasticsearch 查询模板的映射</li><li>多属性条件组合与 Elasticsearch 查询模板的映射关系</li></ul></li></ul><h3 id="基于-ganswer-搭建中英文知识问答系统">9.5.2 基于 gAnswer 搭建中英文知识问答系统</h3><ul><li>gAnswer 是一个基于海量知识库的自然语言问答系统，针对自然语言问题，可以输出 SPARQL 格式的知识库查询表达式以及查询答案的结果</li><li>对于中文问答，使用 PKUBASE 知识库；对于英文问答，使用 DBpedia 知识库</li><li>流程：<ul><li>构建语义查询图</li><li>生成 SPARQL 查询</li><li>查询执行</li></ul></li><li>使用 <strong>gStore 图数据库系统</strong>，输入的知识库的组织形式为三元组形式</li><li>输入新的三元组知识库后，需要建立以下索引文件<ul><li>实体倒排索引</li><li>谓词倒排索引</li><li>实体类型倒排索引</li><li>实体链接倒排索引</li><li>谓词倒排索引</li></ul></li></ul><hr><h1 id="知识图谱应用案例">10. 知识图谱应用案例</h1><h2 id="领域知识图谱的生命周期">10.1 领域知识图谱的生命周期</h2><ul><li><strong>领域知识图谱的生命周期</strong>包括<ul><li>知识建模</li><li>知识存储</li><li>知识抽取</li><li>知识融合</li><li>知识计算</li><li>知识应用</li></ul></li></ul><h3 id="领域知识建模-to-2">10.1.1 领域知识建模 <a href="#2">(To 2)</a></h3><ul><li>建立知识图谱的概念模式</li><li>知识建模的两种方式：<ul><li>自顶向下（Top-Down）<ul><li>首先为知识图谱定义数据模式，然后再将实体添加到概念中</li></ul></li><li>自底向上（Bottom-Up）<ul><li>首先抽取实体，对实体进行归纳组织，然后逐步向上抽象概念</li></ul></li></ul></li><li>知识建模过程需要考虑的几个关键问题：<ul><li>概念划分的合理性</li><li>属性定义方式</li><li>事件、时序等复杂知识表示（匿名节点 / 边属性）</li><li>后续知识扩展的难度</li></ul></li></ul><h3 id="知识存储-to-3">10.1.2 知识存储 <a href="#3">(To 3)</a></h3><ul><li>主流的<strong>知识存储解决方案</strong><ul><li>单一式存储<ul><li>通过三元组、属性表或垂直分割等方式进行存储</li></ul></li><li>混合式存储</li></ul></li><li><strong>知识存储介质的选择</strong><ul><li>原生（Neo4j、AllegroGraph等）</li><li>基于现有数据库（MySQL、Mongo等）</li></ul></li></ul><h3 id="知识抽取-to-4">10.1.3 知识抽取 <a href="#4">(To 4)</a></h3><ul><li>数据的类型：<ul><li>结构化数据<ul><li>关系型数据</li><li>开放链接数据</li></ul></li><li>半结构化数据</li><li>非结构化数据</li></ul></li></ul><h3 id="知识融合-to-6">10.1.4 知识融合 <a href="#6">(To 6)</a></h3><ul><li>知识融合体现了开放链接数据中互联的思想</li><li>知识融合包括：数据模式层的融合和数据层的融合</li></ul><h3 id="知识计算-to-7">10.1.5 知识计算 <a href="#7">(To 7)</a></h3><ul><li>图挖掘算法和知识推理</li><li>知识推理用户知识发现、冲突与异常检测<ul><li>基于本体的推理</li><li>基于规则的推理</li></ul></li><li>图挖掘算法包括<ul><li>图遍历</li><li>最短路径</li><li>权威节点分析</li><li>族群发现最大流算法</li><li>相似节点</li></ul></li></ul><h3 id="知识应用">10.1.6 知识应用</h3><ul><li>典型应用包括<ul><li>语义搜索 <a href="#8">(To 8)</a></li><li>智能问答 <a href="#9">(To 9)</a></li><li>可视化决策支持</li></ul></li></ul><h2 id="领域知识图谱构建的基本方法">10.2 领域知识图谱构建的基本方法</h2><ul><li>包括自顶向下（Top-Down）与自底向上（Bottom-Up）的构建方法</li></ul><h3 id="自顶向下的构建方法">10.2.1 自顶向下的构建方法</h3><ul><li>针对特定行业内有固定知识体系或由该行业专家梳理后可定义模式的数据，大多采用自顶向下的方式构建</li><li>本体建模工具<ul><li>Protege</li><li>PlantData</li></ul></li><li>此时，数据模式的构建基本经过了人工校验，因此知识融合的关键任务是数据层的融合</li></ul><h3 id="自底向上的构建方法">10.2.2 自底向上的构建方法</h3><ul><li>主要分为<strong>实体与概念的学习、上下位关系的学习、数据模式的学习</strong></li><li>主要依赖开放链接数据集和百科</li><li>上下位关系的学习<ul><li>开放链接数据集中拥有明确的描述机制</li><li>百科中描述了两种上下位关系<ul><li>类别之间的上下位（概念层次）</li><li>类别与文章之间的上下位（实体与概念）</li></ul></li></ul></li><li>数据模式的学习又称为概念的属性学习，包括属性名、属性的定义域、属性的值域的学习<ul><li>从开放数据集中获取概念的属性，然后从在线百科中学习实体的属性，并对实体属性进行往上规约从而生成概念的属性</li></ul></li></ul><h2 id="领域知识图谱构建的应用案例">10.3 领域知识图谱构建的应用案例</h2><h3 id="电商eg阿里巴巴-page-428">10.3.1 电商（eg：阿里巴巴） <code>~Page 428~</code></h3><ul><li>知识图谱的核心是商品</li><li>获取来源为知识众包，文本数据</li><li>知识的融合主要利用大规模聚类、大规模实体链指、大规模层次分类等技术</li></ul><h3 id="图情-page-431">10.3.2 图情 <code>~Page 431~</code></h3><ul><li>聚焦某一特定细分行业，以整合行业内图情（图书情报）资源为目标的知识图谱</li><li>提供知识搜索、知识标引、决策支持等形态的知识应用<ul><li>知识标引指根据构建完成的图情知识图谱，对新闻、文献等文本内容进行知识标注的过程</li><li>决策支持基于路径分析、关联分析、节点聚类等图算法进行辅助分析，通过可视化的方式展示知识间的关联</li></ul></li><li>服务于行业内的从业人员、科研机构、行业决策者</li><li>数据源：<ul><li>知网、专利局等文献类网站</li><li>开放通用数据，包括百科类网站以及DBpedia等开放链接数据集</li><li>行业垂直的新闻门户</li><li>行业内企业和科研机构内部积累的既有数据</li></ul></li><li>存储设计<ul><li>对于图谱数据，推荐使用基于 RDF 的存储，如 AllegroGraph、Jena 等</li><li>对于资源数据，则可以使用面向搜索设计的数据库，如 Rlasticsearch、Solr 等</li></ul></li></ul><h3 id="生活娱乐eg美团-page-428">10.3.3 生活娱乐（eg：美团） <code>~Page 428~</code></h3><ul><li>为用户和商家建立全方位的链接。通过对应用场景下的用户偏好和商家定位进行更为深度的理解</li><li>以商户、商品、用户等为主要实体</li><li>利用语言模型、主题模型等深度学习模型，对商家标签、菜品标签、情感分析进行挖掘</li><li>业务应用：<ul><li>智能搜索。<ul><li>帮助用户做决策，为用户搜索出更适合的店</li></ul></li><li>ToB 商户赋能<ul><li>指导店老板决策</li><li>通过阅读每个商家的每一条评论，进行细粒度情感分析，充分理解每个用户对商家的感受</li><li>聚焦于单店的现金流和客源分析</li></ul></li><li>金融风险管理和反欺诈<ul><li>从用户行为建立征信体系</li></ul></li></ul></li></ul><h3 id="企业商业-page-440">10.3.4 企业商业 <code>~Page 440~</code></h3><ul><li>知识图谱中包含企业、任务、专利等实体类型，以及任职、股权、专利所属权等关系类型，以完善企业及个人画像，助理企业潜在客户获取、客户背景调查、多层次研究报告、风险管控；辅助发现不良资产、企业风险、非法集资等</li><li>典型的企业知识图谱：量子魔镜、天眼查、启信宝、企查查、中信建投</li><li>数据源<ul><li>半结构化的网页数据：全国企业信用信息公示系统、中国裁判文书网、中国执行信息公开网、国家知识产权局、商标局、版权局等</li><li>文本数据：招投标信息公告、法律文书、新闻、企业年报等</li></ul></li><li>推荐图数据库的方式存储，并可以扩展分布式存储方案</li><li>应用：金融反欺诈、辅助信贷审核、风险管理、最终控制人分析、战略发展</li></ul><h3 id="创投-page-443">10.3.5 创投 <code>~Page 443~</code></h3><ul><li>聚焦于工商知识图谱的一部分数据内容，旨在展现企业、投融资事件、投资机构之间的关系</li><li><p>数据源：虎嗅、IT 桔子、36Kr 等科技型媒体网站</p></li><li><strong>融资事件</strong>的存储设计：<ul><li>第一种是在传统三元组的基础上，加入其它描述字段，来存储时间、轮次等信息</li><li>第二种是通过匿名节点存储事件，把时间、地点等相关信息作为事件节点的属性</li></ul></li><li>应用：知识检索以及可视化决策支持<ul><li>可视化：节点探索、路径发现、关联探寻、知识地图、时序图谱</li></ul></li></ul><h3 id="中医临床中国中医科学院中医药信息研究所-page-448">10.3.6 中医临床（中国中医科学院中医药信息研究所） <code>~Page 448~</code></h3><ul><li>知识图谱有助于实现临床指南、中医医案以及方剂知识等各类知识的关联与整合，挖掘整理中医临证经验与学术思想，实现智能化、个性化的中医药知识服务，辅助临床决策</li><li>构建过程：<ul><li>基于领域专家设计中医临床领域的顶层本体，形成业界公认的技术规范</li><li>构建目标领域的语义网络，作为知识图谱的骨架（收录概念、术语及语义关系）</li><li>从术语系统、数据库和文本等知识源获取知识，对知识图谱进行填充</li></ul></li><li>从中医医案到知识图谱的知识转换是中医临床知识图谱构建中的核心任务</li><li>临床知识可以分为：事实性知识、概念性知识、策略性知识等多个层次</li></ul><h3 id="金融证券-page-452">10.3.7 金融证券 <code>~Page 452~</code></h3><ul><li>应用模式：金融证券领域文本分析、舆情监控、知识发现、模式挖掘、推理决策。应用场景：智能投研、智能投顾、智能风控、智能客服、智能监管、智能运营等</li><li>金融知识图谱涉及经济、投资、产业、公司、产品、证券、人等相关知识</li><li>构建过程<ul><li>从海量异构非结构化数据中辨别金融实体<ul><li>实体关系抽取技术</li></ul></li><li>定义并挖掘金融实体之间的各种关系，从而生成知识图谱</li><li>定义并表达业务逻辑，在知识图谱上实现各种具体任务</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 理论 </category>
          
          <category> 知识图谱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识图谱理论 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
